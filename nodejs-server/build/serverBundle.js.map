{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"mongoose\"","webpack:///./server.ts","webpack:///external \"express\"","webpack:///external \"morgan\"","webpack:///external \"compression\"","webpack:///external \"body-parser\"","webpack:///external \"helmet\"","webpack:///external \"cors\"","webpack:///external \"dotenv\"","webpack:///external \"socket.io\"","webpack:///external \"lodash\"","webpack:///external \"http\"","webpack:///external \"bcryptjs\"","webpack:///./models/User.js","webpack:///./models/Session.js","webpack:///./models/Room.js","webpack:///external \"crypto\"","webpack:///external \"crypto-js\"","webpack:///external \"fs\"","webpack:///external \"constants\""],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","express","mongoose","morgan","compression","bodyParser","helmet","cors","dotenv_1","IO","lodash_1","http","bcryptjs_1","User_js_1","Session_js_1","Room_js_1","crypto_1","crypto_js_1","fs_1","constants","console","log","images","push","uri","readFileSync","imgs","config","app","use","connect","useNewUrlParser","then","process","env","USER","catch","err","urlencoded","extended","json","req","res","home","success","server","createServer","io","listen","PORT","validateInputs","data","username","password","passwordc","errors","length","isValid","on","socket","id","__awaiter","this","user","default","findOne","to","emit","status","authRefused","publicKey","salt","genSalt","passHashed","hash","userModel","avatar","findIndex","img","save","compare","token","randomBytes","toString","session","_id","newSession","newUser","findById","usr","foundSession","foundUser","payload","savedUser","param","undefined","foundRoom","leader","users","chat","savedRoom","isEmpty","rooms","join","populate","populated","forEach","room","remove","msg","roomName","iv","cipherText","AES","encrypt","CBC","padding","pad","Pkcs7","payloads","buff","Buffer","from","EncryptedKey","publicEncrypt","RSA_PKCS1_PADDING","isImage","isImg","indexOf","requests","request","roomRefIndex","reqIndex","splice","person","requestIndex","pers","reason","__webpack_exports__","mongoose__WEBPACK_IMPORTED_MODULE_0__","mongoose__WEBPACK_IMPORTED_MODULE_0___default","UserSchema","a","Schema","type","String","required","unique","minlength","maxlength","Types","ObjectId","ref","createdAt","Date","now","model","SessionSchema","expires","RoomSchema","Boolean"],"mappings":"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","file":"serverBundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","module.exports = require(\"mongoose\");","import * as express from \"express\";\nimport * as mongoose from \"mongoose\";\nimport * as morgan from \"morgan\";\nimport * as compression from \"compression\";\nimport * as bodyParser from \"body-parser\";\nimport * as helmet from \"helmet\";\nimport * as cors from \"cors\";\nimport { config } from \"dotenv\";\nimport * as IO from \"socket.io\";\nimport { isEmpty } from \"lodash\";\nimport * as http from \"http\";\nimport { genSalt, hash, compare } from \"bcryptjs\";\nimport Usr from \"./models/User.js\";\nimport Session from \"./models/Session.js\";\nimport Room from \"./models/Room.js\";\nimport { randomBytes, createCipheriv, publicEncrypt, createCipher } from \"crypto\";\nimport { mode, AES, enc, pad } from \"crypto-js\";\nimport { readFileSync } from \"fs\";\nvar constants = require(\"constants\");\nconsole.log(constants);\n// Read Images\nlet images = [];\nimages.push({\n  name: \"Av1\",\n  uri:\n    \"data:image/jpeg;base64,\" +\n    readFileSync(\"./assets/avatar1.jpeg\", \"base64\")\n});\nimages.push({\n  name: \"Av2\",\n  uri:\n    \"data:image/jpeg;base64,\" +\n    readFileSync(\"./assets/avatar2.jpeg\", \"base64\")\n});\nimages.push({\n  name: \"Av3\",\n  uri:\n    \"data:image/jpeg;base64,\" +\n    readFileSync(\"./assets/avatar3.jpeg\", \"base64\")\n});\nimages.push({\n  name: \"Av4\",\n  uri:\n    \"data:image/jpeg;base64,\" +\n    readFileSync(\"./assets/avatar4.jpeg\", \"base64\")\n});\nimages.push({\n  name: \"Av5\",\n  uri:\n    \"data:image/jpeg;base64,\" +\n    readFileSync(\"./assets/avatar5.jpeg\", \"base64\")\n});\n// Extra Images\nlet imgs = [];\nimgs.push({\n  name: \"group\",\n  uri:\n    \"data:image/png;base64,\" +\n    readFileSync(\"./assets/group.png\", \"base64\")\n});\nimgs.push({\n  name: \"noAv\",\n  uri:\n    \"data:image/jpeg;base64,\" +\n    readFileSync(\"./assets/noavatar.jpeg\", \"base64\")\n});\n\n// loads .env into process.env\nconfig();\n// // load keys\n// const pkey = readFileSync('key.pem').toString(\"ascii\");\n// const sig = createSign(\"RSA-SHA256\");\n\n// instantiating our server\nconst app: express.Application = express();\n\n// protection layer\napp.use(helmet());\n// connect to mongoose / mongodb , returns a promise\nmongoose\n  .connect(\n    \"mongodb://localhost:27017/Chat\",\n    { useNewUrlParser: true }\n  )\n  .then(() => console.log(`${process.env.USER} Connected to MongoDB `))\n  .catch(err => console.log(err));\n\n// parse application/json\napp.use(bodyParser.urlencoded({ extended: false }));\napp.use(bodyParser.json());\n// cross-origin resource sharing\napp.use(cors());\n// prod mode\napp.use(compression());\napp.use(morgan(\"common\"));\n\napp.get(\"/\", (req, res) => {\n  res.json({ home: \"Key generation route\" });\n});\napp.get(\"**\", (req, res) => {\n  res.json({ success: \"Hello world from express\" });\n});\n\ntype User = {\n  username?: string;\n  password?: string;\n  passwordc?: string;\n  public_key?: string;\n};\n\nconst server = http.createServer(app);\nconst io = IO(server);\nserver.listen(process.env.PORT, () => {\n  console.log(`Express Server on port: ${process.env.PORT}`);\n});\n\n// Form Validation Function\nconst validateInputs = (data: User) => {\n  // Destructuring for better readability\n  const { username, password, passwordc } = data;\n  // initialize an errors object\n  let errors: User = { username: \"\", password: \"\", passwordc: \"\" };\n  // validate the username\n  if (username === null || username === undefined || username === \"\") {\n    errors.username = \"the username is a required field\";\n  } else if (username.length < 3 || username.length > 35) {\n    errors.username = \"يجب على الاسم أن يتكون من 3~35 حرف\";\n  }\n  // validate the password\n  if (password === null || password === undefined || password === \"\") {\n    errors.password = \"the password is a required field\";\n  } else if (password.length < 8 || password.length > 35) {\n    errors.password = \"the password must be 8~35 characters\";\n  } else if (\n    passwordc !== undefined &&\n    passwordc !== null &&\n    passwordc !== password\n  ) {\n    errors.passwordc = \"the two passwords must be equal\";\n  }\n  // if the input form doesn't have password confirmation , delete the error\n  if (passwordc === null || passwordc === undefined) {\n    delete errors.passwordc;\n    if (errors.password + errors.username === \"\") {\n      return { isValid: true, errors };\n    } else {\n      return { isValid: false, errors };\n    }\n  }\n\n  if (errors.password + errors.passwordc + errors.username === \"\") {\n    return { isValid: true, errors };\n  } else {\n    return { isValid: false, errors };\n  }\n};\n\nio.on(\"connection\", socket => {\n  console.log(`socket: ${socket.id} connected`);\n\n  // ~~~ User Registeration Validation ~~~ //\n  socket.on(\"validateRegister\", async (data: User) => {\n    // Server Side Validation Function\n    let { errors, isValid } = validateInputs(data);\n    // Check if the input form is valid\n    if (isValid) {\n      try {\n        // Check If The User Exists\n        let user = await Usr.findOne({ username: data.username });\n        if (user) {\n          errors.passwordc = `${user.username} is used by another user`;\n          io.to(socket.id).emit(\"status\", {\n            status: `${user.username} is used by another user`,\n            errors\n          })\n          return\n        } else {\n          // Emit to the client that the form is valid.. \n          // to generate the RSA keyPair on the client\n          io.to(socket.id).emit(\"validatedInput\", data.username);\n          return;\n        }\n      } catch (err) {\n        console.log(err);\n        return;\n      }\n    } else {\n      io.to(socket.id).emit(\"status\", {\n        status: `${socket.id}'s reg-form is invalid`,\n        errors\n      });\n      console.log({\n        authRefused: `${socket.id}'s reg-form is invalid`,\n        errors\n      });\n    }\n  }); // End of User Registeration Validation <===\n\n  //  Handle User Registeration after the... \n  //  Server Validation + Client RSA Key Generation\n  socket.on(\"register\", async (data) => {\n    let { password, username, publicKey } = data;\n    // At this point we assume that the inputs are valid\n    // Generate a salt ==> hash the password ==> create a new user\n    try {\n      let salt = await genSalt(10);\n      let passHashed = await hash(password, salt)\n      const userModel = new Usr({\n        username: username,\n        password: passHashed,\n        publicKey: publicKey,\n        avatar: imgs[await imgs.findIndex(img => img.name === \"noAv\")]\n      });\n      await userModel.save();\n      io.to(socket.id).emit(\"registered\");\n    } catch (err) {\n      console.log(err);\n      return;\n    }\n\n  });\n\n  // Manage Login Requests\n  socket.on(\"loginRequest\", async data => {\n    let { username, password } = data;\n    console.log(`${username} is trying to login`);\n    const { isValid, errors } = validateInputs(data);\n    // first validation\n    if (isValid) {\n      try {\n        let user = await Usr.findOne({ username });\n        if (user) {\n          // The user exists , compare the password with the saved hash\n          let passValid = await compare(password, user.password);\n          if (passValid) {\n            // The password is valid = The user is authenticated\n            // Generate Authentication Token\n            let token = await randomBytes(32).toString(\"hex\");\n            // Create a new Session Model to store the new token\n            let session = await new Session({\n              token,\n              user: user._id\n            })\n            // Mutate the User's Model to add the new Session's Id\n            user.session = session._id;\n            // Save The mutated/new Models\n            let newSession = await session.save();\n            let newUser = await user.save();\n            // Emit data to the client\n            io.to(socket.id).emit(\"token\", {\n              token: newSession.token,\n              publicKey: newUser.publicKey,\n              avatar: newUser.avatar,\n              username: newUser.username,\n            })\n          } else {\n            // The password is Invalid \n            errors.password = \"The password is invalid\";\n            io.to(socket.id).emit(\"status\", { status: \"The password is Invalid\", errors })\n            return;\n          }\n        } else {\n          // The user doesn't exist in the database\n          errors.password = \"The user doesn't exist\"\n          console.log(\"the user doesn't exist\");\n          io.to(socket.id).emit(\"status\", { status: \"The user doesn't exist\", errors })\n          return;\n        }\n\n      } catch (err) {\n        console.log(err)\n      }\n    } else {\n      // The Registeration Form is Invalid\n      io.to(socket.id).emit(\"status\", { status: \"invalid registeration form\", errors })\n      return;\n    }\n  })\n\n\n  // Assigning new public key's to current users\n  socket.on(\"assignKey\", async data => {\n    console.log(\"Assigning a new key\");\n    let { token, username, publicKey } = data;\n    try {\n      let session = await Session.findOne({ token });\n      if (session) {\n        // The Session Exists\n        let user = await Usr.findById(session.user);\n        if (user) {\n          user.publicKey = publicKey;\n          let newUser = await user.save();\n          io.to(socket.id).emit(\"keyPairAssigned\", {\n            token: session.token,\n            username: newUser.username,\n            avatar: newUser.avatar\n          })\n        } else {\n          console.log(\"The User Doesn't Exist\");\n          return;\n        }\n      } else {\n        console.log(\"The Session Doesn't Exist\");\n        return;\n      }\n    } catch (err) {\n      console.log(err);\n    }\n  });\n\n  // Handle Token Validation requests\n  socket.on(\"validateToken\", async token => {\n    let session = await Session.findOne({ token });\n    if (session) {\n      console.log(\"The Session Exists\");\n      let user = await Usr.findById(session.user);\n      if (user) {\n        console.log(\"Token is Valid\");\n        // The Token is still Valid ===Emit(validToken)===> Client to validate the keyPair\n        let data = {\n          token: session.token,\n          avatar: user.avatar,\n          username: user.username,\n          publicKey: user.publicKey\n        }\n        // next step is RSA key validation\n        io.to(socket.id).emit(\"validToken\", data)\n        return;\n      } else {\n        console.log(\"The User Doesn't Exist\");\n        return;\n      }\n    } else {\n      console.log(\"TokenValidation:||:The Session Doesn't Exist\");\n      return;\n    }\n\n  });\n  // Send an Array of Images to the Profile page\n  socket.on(\"getImagesArray\", data => {\n    if (images.length === 5) {\n      Session.findOne({ token: data.token }, (err, session) => {\n        if (err) {\n          console.log(err);\n          return;\n        } else if (session !== null && session !== undefined) {\n          Usr.findById(session.user, (err, usr) => {\n            if (err) {\n              console.log(err);\n              return;\n            } else if (usr !== null && usr !== undefined) {\n              io.to(socket.id).emit(\"imagesArray\", images);\n            }\n          });\n        }\n      });\n    }\n  });\n  // Handle Profile Save\n  socket.on(\"saveProfile\", data => {\n    console.log(\"Received Image data\");\n    Session.findOne({ token: data.token }, (err, foundSession) => {\n      if (err) console.log(err);\n      else if (foundSession !== undefined && foundSession !== null) {\n        Usr.findById(foundSession.user, (err, foundUser) => {\n          if (err) {\n            console.log(err);\n            return;\n          } else if (foundUser !== null && foundUser !== undefined) {\n            const payload = {\n              token: foundSession.token,\n              username: foundUser.username,\n              avatar: foundUser.avatar\n            };\n            if (data.avatar === foundUser.avatar) {\n              io.to(socket.id).emit(\"profileSaved\", payload);\n              return;\n            } else {\n              foundUser.avatar = data.avatar;\n              foundUser.save((err, savedUser) => {\n                if (err) console.log(err);\n                else if (savedUser !== null && savedUser !== null) {\n                  const param = {\n                    token: foundSession.token,\n                    username: savedUser.username,\n                    avatar: savedUser.avatar\n                  };\n                  console.log(\"Saved profile\");\n                  io.to(socket.id).emit(\"profileSaved\", param);\n                }\n              });\n            }\n          }\n        });\n      }\n    });\n  }); // End of Saving Profile\n\n  // Handle Room Creation\n  socket.on(\"createRoom\", data => {\n    Session.findOne({ token: data.token }, (err, foundSession) => {\n      if (err) {\n        console.log(err);\n        return;\n      } else if (foundSession === null || foundSession === undefined) {\n        console.log(\"Failed to fetch Session your token must be invalid\");\n      } else {\n        if (data.name === null || data.name === undefined || data.name === \"\") {\n          io.to(socket.id).emit(\"groupFormError\", \"اكتب اسم المجموعة\");\n        } else if (data.name.length < 3 || data.name.length > 30) {\n          io.to(socket.id).emit(\"groupFormError\", \"يجب على الاسم ان يتكون من 3~30 حرف\");\n        } else {\n          Room.findOne({ name: data.name }, (err, foundRoom) => {\n            if (err) {\n              console.log(err);\n              return;\n            } else if (foundRoom) {\n              io.to(socket.id).emit(\"groupFormError\", \"the name is taken\")\n            } else {\n              Usr.findById(\n                foundSession.user,\n                [\"rooms\", \"username\"],\n                (err, foundUser) => {\n                  if (err) {\n                    console.log(err);\n                  } else if (foundUser !== null && foundUser !== undefined) {\n                    const newRoom = new Room({\n                      leader: foundUser.username,\n                      name: data.name,\n                      users: [foundUser._id],\n                      chat: []\n                    });\n                    newRoom.save((err, savedRoom) => {\n                      if (err) {\n                        console.log(err);\n                        return;\n                      } else {\n                        if (isEmpty(foundUser.rooms)) {\n                          foundUser.rooms = [savedRoom._id];\n                        } else {\n                          foundUser.rooms.push(savedRoom._id);\n                        }\n                        foundUser.save((err, savedUser) => {\n                          if (err) {\n                            console.log(err);\n                            return;\n                          } else {\n                            console.log(\"Saved User & Room\", savedUser);\n                            socket.join(savedRoom.name);\n                            io.to(socket.id).emit(\"roomCreated\", savedRoom);\n                          }\n                        });\n                      }\n                    });\n                  } else {\n                    console.log(\"The User doesn't Exist\");\n                  }\n                }\n              );\n            }\n          });\n        }\n      }\n    });\n  });\n  // Handle Fetching/joining the rooms\n  socket.on(\"getRooms\", token => {\n    console.log(token);\n    Session.findOne({ token: token }, (err, foundSession) => {\n      if (err) {\n        console.log(err);\n        return;\n      } else if (foundSession === null || foundSession === undefined) {\n        console.log(\"The Session Doesn't Exists\");\n        return;\n      } else {\n        Usr.findById(foundSession.user, [\"rooms\", \"username\"])\n          .then(foundUser => {\n            foundUser.populate(\"rooms\", (err, populated) => {\n              populated.rooms.forEach((room, i) => {\n                console.log(room);\n                socket.join(room.name);\n                console.log(\"Joined\", room.name);\n              });\n              io.to(socket.id).emit(\"rooms\", populated.rooms);\n            });\n          })\n          .catch(err => console.log(err));\n      }\n    });\n  });\n  // Handle Logout , Delete Session\n  socket.on(\"logout\", data => {\n    console.log(`${data.username} is logging out`);\n    Session.findOne({ token: data.token }, (err, foundSession) => {\n      if (err) {\n        console.log(err);\n        return;\n      } else if (foundSession === null || foundSession === undefined) {\n        console.log(\"The Session Doesn't Exist\");\n        return;\n      } else {\n        foundSession.remove();\n        console.log(\"The Session is Removed\");\n        io.to(socket.id).emit(\"logedout\");\n      }\n    });\n  });\n\n  // Handle New Text Msgs\n  socket.on(\"newMsg\", data => {\n    const { msg, token, roomName } = data;\n    Session.findOne({ token: token }, (err, foundSession) => {\n      if (err) {\n        console.log(err);\n        return;\n      } else if (foundSession === null || foundSession === undefined) {\n        console.log(\"the token is expired\");\n      } else {\n        Usr.findById(foundSession.user)\n          .then(foundUser => {\n            if (foundUser === null || foundUser === undefined) {\n              console.log(\"The User Doesn't Exist\");\n              return;\n            } else {\n              Room.findOne({ name: roomName })\n                .populate(\"users\", [\"publicKey\", \"username\"])\n                .then(foundRoom => {\n                  if (foundRoom === null || foundRoom === undefined) {\n                    console.log(\"the room doesn't exist\");\n                    return;\n                  } else {\n                    // Initialization vector\n                    let iv = randomBytes(8).toString(\"hex\");\n                    // Symmetric encryption key AES 256bit/32bytes\n                    let key = randomBytes(32).toString(\"hex\");\n                    // Encrypted Bytes\n                    let encrypted = AES.encrypt(msg, key, { iv: iv, mode: mode.CBC, padding: pad.Pkcs7 })\n                    // CipherText\n                    let cipherText = encrypted.toString();\n                    console.log(\"cipher-text\", cipherText);\n                    let payloads = []; // each user in the room has an encrypted payload\n                    let buff = Buffer.from(key);\n                    let from = foundUser.username;\n                    let to = []; // array of \n                    foundRoom.users.forEach((user, i) => {\n                      let EncryptedKey = publicEncrypt(\n                        {\n                          key: user.publicKey,\n                          padding: constants.RSA_PKCS1_PADDING\n                        },\n                        buff\n                      ).toString(\"base64\");\n                      payloads.push({\n                        roomName: foundRoom.name,\n                        from: foundUser.username,\n                        msg: cipherText,\n                        key: EncryptedKey,\n                        publicKey: user.publicKey,\n                        iv\n                      });\n                      to.push({\n                        publicKey: user.publicKey,\n                        key: EncryptedKey,\n                        username: user.username\n                      });\n                    });\n                    if (\n                      foundRoom.chat === null ||\n                      foundRoom.chat === undefined ||\n                      foundRoom.chat.length === 0\n                    ) {\n                      foundRoom.chat = [\n                        { from, to, msg: cipherText, isImage: false, iv }\n                      ];\n                    } else {\n                      foundRoom.chat.push({\n                        from, to, msg: cipherText, isImg: false, iv\n                      });\n                    }\n                    foundRoom.save()\n                      .then(savedRoom => {\n                        console.log(\"Saved Room\", savedRoom.name);\n                        console.log(payloads);\n                        io.to(savedRoom.name).emit(\"Msg\", payloads);\n                      })\n                      .catch(err => console.log(err));\n\n                  }\n                })\n                .catch(err => console.log(err));\n            }\n          })\n          .catch(err => console.log(err));\n      }\n    });\n  });\n\n  // Handle Group Invitations ( group/room Leader ==Invites==> User)\n  socket.on(\"invite\", data => {\n    const { room, user, username } = data;\n    if (user === null || user === undefined || user === \"\") {\n      io.to(socket.id).emit(\"groupFormError\", \"اكتب اسم الشحص\");\n    } else if (user.length < 3 || user.length > 30) {\n      io.to(socket.id).emit(\"groupFormError\", \"يجب على الاسم أن يتكون من 3~35 حرف\");\n    } else {\n      Usr.findOne({ username: user }, (err, foundUser) => {\n        if (err) {\n          console.log(err);\n          return;\n        } else if (foundUser === null || foundUser === undefined) {\n          io.to(socket.id).emit(\"groupFormError\", \"لا يوجد هذا الشخص\");\n        } else {\n          Room.findOne({ name: room }, (err, foundRoom) => {\n            if (err) {\n              console.log(err);\n              return;\n            } else if (foundRoom === null || foundRoom === undefined) {\n              console.log(\"The Room doesn't Exist\");\n            } else {\n              if (foundRoom.leader === username) {\n                // The user is not in the room already\n                if (foundUser.rooms.indexOf(foundRoom._id) === -1) {\n                  // foundUser.rooms.push(foundRoom._id);\n                  // foundRoom.users.push(foundUser._id);\n                  let requestIndex = foundUser.requests.findIndex(request => request.roomName === foundRoom.name);\n                  if (requestIndex === -1) {\n                    foundUser.requests.push({ roomName: foundRoom.name, leader: foundRoom.leader })\n                    foundUser.save((err, savedUser) => {\n                      if (err) {\n                        console.log(err);\n                        return;\n                      } else {\n                        io.to(socket.id).emit(\"invited\");\n                        console.log(`Invited ${foundUser.username} ==room==> ${foundRoom.name} `);\n                      }\n                    });\n                  } else {\n                    io.to(socket.id).emit(\"groupFormError\", \"انتظر الشخص لكي يستجيب لدعوتك\");\n                  }\n\n                } else {\n                  io.to(socket.id).emit(\"groupFormError\", \"هذا الشخص عضو في المجموعة\");\n                }\n              } else {\n                console.log(\"you have to be the leader of the room to invite\");\n              }\n            }\n          });\n        }\n      });\n    }\n  });\n  // User Requests (Group Invitations from Group Leaders)\n  socket.on(\"getRequests\", token => {\n    Session.findOne({ token })\n      .then(session => {\n        if (session === null || session === undefined) {\n          console.log(\"The Session is Expired\");\n          return;\n        } else {\n          Usr.findById(session.user)\n            .then(user => {\n              if (user === null || user === undefined) {\n                console.log(\"The User is unavailable\");\n                return;\n              } else {\n                io.to(socket.id).emit(\"userRequests\", user.requests);\n                console.log(`Sent userRequests to ${user.username}`, user.requests);\n                return;\n              }\n            })\n        }\n      }).catch(err => console.log(err))\n  })\n\n  // Accept Invitation Requests to join a room\n  socket.on(\"acceptUserRequest\", data => {\n    let { token, roomName } = data;\n    Session.findOne({ token })\n      .then(session => {\n        if (session === null || session === undefined) {\n          console.log(\"The Session is Expired\");\n          return;\n        } else {\n          Usr.findById(session.user)\n            .then(user => {\n              if (user === null || user === undefined) {\n                console.log(\"The User is unavailable\");\n                return;\n              } else {\n                Room.findOne({ name: roomName })\n                  .then(room => {\n                    if (room === null || room === undefined) {\n                      console.log(\"The Room is unavailable\");\n                    } else {\n                      // Check if the user is already a member in the group/room\n                      let roomRefIndex = user.rooms.indexOf(room._id);\n                      console.log(\"refIndex\", roomRefIndex);\n                      if (roomRefIndex === -1) {\n                        // the user doesn't exist in the room\n                        room.users.push(user._id);\n                        user.rooms.push(room._id);\n                        let reqIndex = user.requests.findIndex(req => req.roomName === roomName);\n                        user.requests.splice(reqIndex, 1);\n                        room.save()\n                          .then(savedRoom => {\n                            user.save()\n                              .then(savedUser => {\n                                console.log(`${savedUser.username} joined ${savedRoom.name}`);\n                                socket.join(savedRoom.name);\n                                io.to(socket.id).emit(\"invitationAccepted\", savedRoom.name);\n                              }).catch(err => console.log(err));\n                          })\n                          .catch(err => console.log(err))\n                      } else {\n                        console.log(\"you are a member of this group\")\n                      }\n                    }\n                  })\n                  .catch(err => console.log(err))\n              }\n            })\n        }\n      }).catch(err => console.log(err))\n  })\n  // Refuse / Delete Invitation Request\n  socket.on(\"refuseUserRequest\", async (data) => {\n    let { token, roomName } = data;\n    try {\n      let session = await Session.findOne({ token });\n      if (session === null || session === undefined) {\n        console.log(\"The Session Doesn't Exist\");\n        return\n      } else {\n        let user = await Usr.findById(session.user);\n        if (user === null || user === undefined) {\n          console.log(\"The User Doesn't Exist\");\n          return\n        } else {\n          let reqIndex = await user.requests.findIndex(req => req.roomName === roomName);\n          await user.requests.splice(reqIndex, 1);\n          let savedUser = await user.save();\n          console.log(`A User Invitation Has Been Deleted`, savedUser.requests);\n          io.to(socket.id).emit(\"deletedUserRequest\", roomName);\n        }\n      }\n    } catch (err) {\n      console.log(err);\n    }\n  })\n  // Refuse / Delete Room Request (Requests sent from Users ===> Room Leaders)\n  socket.on(\"refuseRoomRequest\", async (data) => {\n    let { token, roomName, person } = data;\n    try {\n      let session = await Session.findOne({ token });\n      if (session === null || session === undefined) {\n        console.log(\"The Session Doesn't Exist\");\n        return\n      } else {\n        let user = await Usr.findById(session.user);\n        if (user === null || user === undefined) {\n          console.log(\"The User Doesn't Exist\");\n          return\n        } else {\n          let room = await Room.findOne({ name: roomName });\n          if (room) {\n            let requestIndex = room.requests.indexOf(person);\n            if (requestIndex !== -1) {\n              await room.requests.splice(requestIndex, 1);\n              await room.save();\n              io.to(socket.id).emit(\"roomRequestAccepted\", { person, roomName });\n            } else {\n              console.log(\"The Request Doesn't exist\");\n              return;\n            }\n          } else {\n            console.log(\"The room doesn't exist\");\n            return;\n          }\n        }\n      }\n    } catch (err) {\n      console.log(err);\n    }\n  })\n  // (Users Ask (Request) Room/Group Leader to join)\n  socket.on(\"joinRequest\", async (data) => {\n    const { token, name } = data;\n    // Input Validation\n    if (name === null || name === undefined || name === \"\") {\n      io.to(socket.id).emit(\"groupFormError\", \"اكتب اسم المجموعة\");\n    } else if (name.length < 3 || name.length > 35) {\n      io.to(socket.id).emit(\"groupFormError\", \"يجب على اسم المجموعة أن تتكون من 3~35 حرف\");\n    } else {\n      try {\n        let session = await Session.findOne({ token });\n        if (session === null || session === undefined) {\n          console.log(\"The Session is Expired\");\n          return;\n        } else {\n          let user = await Usr.findById(session.user);\n          if (user === null || user === undefined) {\n            console.log(\"The User doesn't exist\");\n            return;\n          } else {\n            let room = await Room.findOne({ name });\n            if (room === null || room === undefined) {\n              console.log(\"The Room doesn't exist\");\n              io.to(socket.id).emit(\"groupFormError\", \"لا توجد هذه مجموعة\");\n              return;\n            } else {\n              let reqIndex = await room.requests.indexOf(user.username);\n              let userIndex = await room.users.indexOf(user._id);\n              if (userIndex !== -1) {\n                io.to(socket.id).emit(\"groupFormError\", \"أنت عضو في هذه المجموعة\");\n              } else if (reqIndex === -1) {\n                await room.requests.push(user.username);\n                let savedRoom = await room.save();\n                console.log(`${user.username} ==Requests==> ${savedRoom.leader} to join ${savedRoom.name}`);\n                io.to(socket.id).emit(\"requestSent\");\n              } else {\n                console.log(\"The Request already exists\");\n                io.to(socket.id).emit(\"groupFormError\", \"انتظر الرد على طلب الدخول\");\n              }\n            }\n          }\n        }\n      } catch (err) {\n        console.log(err);\n      }\n    }\n  })\n\n  // Accept Room  Requests to join ( Normal User ==Requests== Room Leader)\n  socket.on(\"acceptRoomRequest\", async (data) => {\n    let { token, roomName, person } = data;\n    try {\n      // get the session by token\n      let session = await Session.findOne({ token });\n      if (!session) {\n        console.log(\"The Session Doesn't Exist\");\n        return\n      } else {\n        // check if the user exists\n        let user = await Usr.findById(session.user);\n        if (!user) {\n          console.log(\"The User Doesn't Exist\");\n          return\n        } else {\n          // get the person that you want to add to the room\n          let pers = await Usr.findOne({ username: person }); // person to add to the room\n          if (pers) {\n            // get the room by room name\n            let room = await Room.findOne({ name: roomName });\n            if (room) {\n              // Check if the user already exists in the room (This might never happen)\n              let personIndex = await room.users.indexOf(pers._id);\n              if (personIndex === -1) {\n                // the user doesn't exist in the room\n                await room.users.push(pers._id);\n                // find the request index to delete it\n                let reqIndex = await room.requests.indexOf(pers.username);\n                if (reqIndex !== -1) {\n                  await room.requests.splice(reqIndex, 1)\n                } else {\n                  console.log(\"The Request Doesn't Exist\");\n                }\n                let savedRoom = await room.save();\n                await pers.rooms.push(savedRoom._id);\n                pers.save();\n                console.log(`${savedRoom.leader} accepted ${pers.username}'s request to join ${room.name}`);\n                io.to(socket.id).emit(\"roomRequestAccepted\", { person: pers.username, roomName: savedRoom.name, id: pers._id });\n              } else {\n                console.log(`${pers.username} already exists in ${room.name}`);\n                return;\n              }\n            } else {\n              console.log(\"The Room Doesn't Exist\");\n              return;\n            }\n          } else {\n            // this happpens when an account is deleted \n            console.log(\"The Person you want to invite doesn't exist\")\n            return;\n          }\n        }\n      }\n    } catch (err) {\n      console.log(err);\n    }\n  })\n  socket.on(\"disconnect\", (reason) => {\n    console.log(`${socket.id} disconnected!!`);\n    console.log(`reason`, reason);\n  });\n});\n","module.exports = require(\"express\");","module.exports = require(\"morgan\");","module.exports = require(\"compression\");","module.exports = require(\"body-parser\");","module.exports = require(\"helmet\");","module.exports = require(\"cors\");","module.exports = require(\"dotenv\");","module.exports = require(\"socket.io\");","module.exports = require(\"lodash\");","module.exports = require(\"http\");","module.exports = require(\"bcryptjs\");","import mongoose from \"mongoose\";\n\nconst UserSchema = new mongoose.Schema({\n  username: {\n    type: String,\n    required: true,\n    unique: true,\n    minlength: 3,\n    maxlength: 35\n  },\n  password: {\n    type: String,\n    required: true\n  },\n  publicKey: {\n    type: String,\n    required: true,\n    unique: true\n  },\n  session: {\n    type: mongoose.Schema.Types.ObjectId,\n    ref: \"Session\",\n    required: false\n  },\n  avatar: {},\n  rooms: {\n    type: [{ type: mongoose.Schema.Types.ObjectId, ref: \"Room\" }],\n    default: []\n  },\n  requests: { type: [{ roomName: String, leader: String }], default: [] },\n  createdAt: {\n    type: Date,\n    default: Date.now\n  }\n});\n\nexport default mongoose.model(\"User\", UserSchema);\n","import mongoose from \"mongoose\";\nconst SessionSchema = new mongoose.Schema({\n  createdAt: {\n    type: Date,\n    default: Date.now,\n    expires: \"1d\"\n  },\n  token: {\n    type: String,\n    unique: true\n  },\n  user: { type: mongoose.Schema.Types.ObjectId, ref: \"User\" }\n});\n\nexport default mongoose.model(\"Session\", SessionSchema);\n","import mongoose from \"mongoose\";\nconst RoomSchema = new mongoose.Schema({\n  createdAt: {\n    type: Date,\n    default: Date.now\n  },\n  name: {\n    type: String,\n    unique: true,\n    required: true,\n    minlength: 3,\n    maxlength: 35\n  },\n  requests: { type: [String], default: [] },\n  users: [{ type: mongoose.Schema.Types.ObjectId, ref: \"User\" }],\n  leader: String,\n  chat: {\n    type: [\n      {\n        iv: String, // Hex encoded Initialization vector\n        msg: String, // base64 encoded , AES 256 Encrypted cipher text\n        from: String, // sender\n        to: [{\n          publicKey: String, // RSA public key string/pem\n          username: String,\n          key: String, // Base64 encoded ,AES 256 Encrypted Key\n        }],\n        isImg: Boolean,\n        createdAt: { type: Date, default: Date.now }\n      }\n    ],\n    default: []\n  }\n});\n\nexport default mongoose.model(\"Room\", RoomSchema);\n","module.exports = require(\"crypto\");","module.exports = require(\"crypto-js\");","module.exports = require(\"fs\");","module.exports = require(\"constants\");"],"sourceRoot":""}
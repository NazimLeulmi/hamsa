{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"mongoose\"","webpack:///./server.ts","webpack:///external \"express\"","webpack:///external \"morgan\"","webpack:///external \"compression\"","webpack:///external \"body-parser\"","webpack:///external \"helmet\"","webpack:///external \"cors\"","webpack:///external \"dotenv\"","webpack:///external \"socket.io\"","webpack:///external \"http\"","webpack:///external \"bcryptjs\"","webpack:///./models/User.js","webpack:///./models/Session.js","webpack:///./models/Room.js","webpack:///external \"crypto\"","webpack:///external \"crypto-js\"","webpack:///external \"fs\"","webpack:///external \"constants\""],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","express","mongoose","morgan","compression","bodyParser","helmet","cors","dotenv_1","IO","http","bcryptjs_1","User_js_1","Session_js_1","Room_js_1","crypto_1","crypto_js_1","fs_1","constants","console","log","images","push","uri","readFileSync","imgs","config","app","use","connect","useNewUrlParser","then","process","env","USER","catch","err","urlencoded","extended","json","req","res","home","success","server","createServer","io","listen","PORT","validateInputs","data","username","password","passwordc","errors","length","isValid","on","socket","id","__awaiter","this","user","default","findOne","to","emit","status","authRefused","publicKey","salt","genSalt","passHashed","hash","userModel","avatar","findIndex","img","save","compare","token","randomBytes","toString","session","_id","newSession","newUser","findById","usr","foundSession","foundUser","payload","savedUser","param","newRoom","leader","users","rooms","savedRoom","join","populate","forEach","room","remove","msg","roomName","iv","cipherText","AES","encrypt","CBC","padding","pad","Pkcs7","buff","Buffer","from","encKey","publicEncrypt","RSA_PKCS1_PADDING","chat","isImg","foundRoom","indexOf","requests","request","roomRefIndex","reqIndex","splice","person","requestIndex","pers","reason","__webpack_exports__","mongoose__WEBPACK_IMPORTED_MODULE_0__","mongoose__WEBPACK_IMPORTED_MODULE_0___default","UserSchema","a","Schema","type","String","required","unique","minlength","maxlength","Types","ObjectId","ref","createdAt","Date","now","model","SessionSchema","expires","RoomSchema","Boolean"],"mappings":"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","file":"serverBundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","module.exports = require(\"mongoose\");","import * as express from \"express\";\nimport * as mongoose from \"mongoose\";\nimport * as morgan from \"morgan\";\nimport * as compression from \"compression\";\nimport * as bodyParser from \"body-parser\";\nimport * as helmet from \"helmet\";\nimport * as cors from \"cors\";\nimport { config } from \"dotenv\";\nimport * as IO from \"socket.io\";\nimport { isEmpty } from \"lodash\";\nimport * as http from \"http\";\nimport { genSalt, hash, compare } from \"bcryptjs\";\nimport Usr from \"./models/User.js\";\nimport Session from \"./models/Session.js\";\nimport Room from \"./models/Room.js\";\nimport { randomBytes, publicEncrypt } from \"crypto\";\nimport { mode, AES, enc, pad } from \"crypto-js\";\nimport { readFileSync } from \"fs\";\nvar constants = require(\"constants\");\nconsole.log(constants);\n// Read Images\nlet images = [];\nimages.push({\n  name: \"Av1\",\n  uri:\n    \"data:image/png;base64,\" +\n    readFileSync(\"./assets/avatar1.png\", \"base64\")\n});\nimages.push({\n  name: \"Av2\",\n  uri:\n    \"data:image/png;base64,\" +\n    readFileSync(\"./assets/avatar2.png\", \"base64\")\n});\nimages.push({\n  name: \"Av3\",\n  uri:\n    \"data:image/png;base64,\" +\n    readFileSync(\"./assets/avatar3.png\", \"base64\")\n});\nimages.push({\n  name: \"Av4\",\n  uri:\n    \"data:image/png;base64,\" +\n    readFileSync(\"./assets/avatar4.png\", \"base64\")\n});\nimages.push({\n  name: \"Av5\",\n  uri:\n    \"data:image/png;base64,\" +\n    readFileSync(\"./assets/avatar5.png\", \"base64\")\n});\n// Extra Images\nlet imgs = [];\nimgs.push({\n  name: \"group\",\n  uri:\n    \"data:image/png;base64,\" +\n    readFileSync(\"./assets/group.png\", \"base64\")\n});\nimgs.push({\n  name: \"noAv\",\n  uri:\n    \"data:image/png;base64,\" +\n    readFileSync(\"./assets/noavatar.jpeg\", \"base64\")\n});\n\n// loads .env into process.env\nconfig();\n// // load keys\n// const pkey = readFileSync('key.pem').toString(\"ascii\");\n// const sig = createSign(\"RSA-SHA256\");\n\n// instantiating our server\nconst app: express.Application = express();\n\n// protection layer\napp.use(helmet());\n// connect to mongoose / mongodb , returns a promise\nmongoose\n  .connect(\n    \"mongodb://localhost:27017/Chat\",\n    { useNewUrlParser: true }\n  )\n  .then(() => console.log(`${process.env.USER} Connected to MongoDB `))\n  .catch(err => console.log(err));\n\n// parse application/json\napp.use(bodyParser.urlencoded({ extended: false }));\napp.use(bodyParser.json());\n// cross-origin resource sharing\napp.use(cors());\n// prod mode\napp.use(compression());\napp.use(morgan(\"common\"));\n\napp.get(\"/\", (req, res) => {\n  res.json({ home: \"Key generation route\" });\n});\napp.get(\"**\", (req, res) => {\n  res.json({ success: \"Hello world from express\" });\n});\n\ntype User = {\n  username?: string;\n  password?: string;\n  passwordc?: string;\n  public_key?: string;\n};\n\nconst server = http.createServer(app);\nconst io = IO(server);\nserver.listen(process.env.PORT, () => {\n  console.log(`Express Server on port: ${process.env.PORT}`);\n});\n\n// Form Validation Function\nconst validateInputs = (data: User) => {\n  // Destructuring for better readability\n  const { username, password, passwordc } = data;\n  // initialize an errors object\n  let errors: User = { username: \"\", password: \"\", passwordc: \"\" };\n  // validate the username\n  if (username === null || username === undefined || username === \"\") {\n    errors.username = \"the username is a required field\";\n  } else if (username.length < 3 || username.length > 35) {\n    errors.username = \"يجب على الاسم أن يتكون من 3~35 حرف\";\n  }\n  // validate the password\n  if (password === null || password === undefined || password === \"\") {\n    errors.password = \"the password is a required field\";\n  } else if (password.length < 8 || password.length > 35) {\n    errors.password = \"the password must be 8~35 characters\";\n  } else if (\n    passwordc !== undefined &&\n    passwordc !== null &&\n    passwordc !== password\n  ) {\n    errors.passwordc = \"the two passwords must be equal\";\n  }\n  // if the input form doesn't have password confirmation , delete the error\n  if (passwordc === null || passwordc === undefined) {\n    delete errors.passwordc;\n    if (errors.password + errors.username === \"\") {\n      return { isValid: true, errors };\n    } else {\n      return { isValid: false, errors };\n    }\n  }\n\n  if (errors.password + errors.passwordc + errors.username === \"\") {\n    return { isValid: true, errors };\n  } else {\n    return { isValid: false, errors };\n  }\n};\n\nio.on(\"connection\", socket => {\n  console.log(`socket: ${socket.id} connected`);\n\n  // ~~~ User Registeration Validation ~~~ //\n  socket.on(\"validateRegister\", async (data: User) => {\n    // Server Side Validation Function\n    let { errors, isValid } = validateInputs(data);\n    // Check if the input form is valid\n    if (isValid) {\n      try {\n        // Check If The User Exists\n        let user = await Usr.findOne({ username: data.username });\n        if (user) {\n          errors.passwordc = `${user.username} is used by another user`;\n          io.to(socket.id).emit(\"status\", {\n            status: `${user.username} is used by another user`,\n            errors\n          })\n          return\n        } else {\n          // Emit to the client that the form is valid.. \n          // to generate the RSA keyPair on the client\n          io.to(socket.id).emit(\"validatedInput\", data.username);\n          return;\n        }\n      } catch (err) {\n        console.log(err);\n        return;\n      }\n    } else {\n      io.to(socket.id).emit(\"status\", {\n        status: `${socket.id}'s reg-form is invalid`,\n        errors\n      });\n      console.log({\n        authRefused: `${socket.id}'s reg-form is invalid`,\n        errors\n      });\n    }\n  }); // End of User Registeration Validation <===\n\n  //  Handle User Registeration after the... \n  //  Server Validation + Client RSA Key Generation\n  socket.on(\"register\", async (data) => {\n    let { password, username, publicKey } = data;\n    // At this point we assume that the inputs are valid\n    // Generate a salt ==> hash the password ==> create a new user\n    try {\n      let salt = await genSalt(10);\n      let passHashed = await hash(password, salt)\n      const userModel = new Usr({\n        username: username,\n        password: passHashed,\n        publicKey: publicKey,\n        avatar: imgs[await imgs.findIndex(img => img.name === \"noAv\")]\n      });\n      await userModel.save();\n      io.to(socket.id).emit(\"registered\");\n    } catch (err) {\n      console.log(err);\n      return;\n    }\n\n  });\n\n  // Manage Login Requests\n  socket.on(\"loginRequest\", async data => {\n    let { username, password } = data;\n    console.log(`${username} is trying to login`);\n    const { isValid, errors } = validateInputs(data);\n    // first validation\n    if (isValid) {\n      try {\n        let user = await Usr.findOne({ username });\n        if (user) {\n          // The user exists , compare the password with the saved hash\n          let passValid = await compare(password, user.password);\n          if (passValid) {\n            // The password is valid = The user is authenticated\n            // Generate Authentication Token\n            let token = await randomBytes(32).toString(\"hex\");\n            // Create a new Session Model to store the new token\n            let session = await new Session({\n              token,\n              user: user._id\n            })\n            // Mutate the User's Model to add the new Session's Id\n            user.session = session._id;\n            // Save The mutated/new Models\n            let newSession = await session.save();\n            let newUser = await user.save();\n            // Emit data to the client\n            io.to(socket.id).emit(\"token\", {\n              token: newSession.token,\n              publicKey: newUser.publicKey,\n              avatar: newUser.avatar,\n              username: newUser.username,\n            })\n          } else {\n            // The password is Invalid \n            errors.password = \"The password is invalid\";\n            io.to(socket.id).emit(\"status\", { status: \"The password is Invalid\", errors })\n            return;\n          }\n        } else {\n          // The user doesn't exist in the database\n          errors.password = \"The user doesn't exist\"\n          console.log(\"the user doesn't exist\");\n          io.to(socket.id).emit(\"status\", { status: \"The user doesn't exist\", errors })\n          return;\n        }\n\n      } catch (err) {\n        console.log(err)\n      }\n    } else {\n      // The Registeration Form is Invalid\n      io.to(socket.id).emit(\"status\", { status: \"invalid registeration form\", errors })\n      return;\n    }\n  })\n\n\n  // Assigning new public key's to current users\n  socket.on(\"assignKey\", async data => {\n    console.log(\"Assigning a new key\");\n    let { token, username, publicKey } = data;\n    try {\n      let session = await Session.findOne({ token });\n      if (session) {\n        // The Session Exists\n        let user = await Usr.findById(session.user);\n        if (user) {\n          user.publicKey = publicKey;\n          let newUser = await user.save();\n          io.to(socket.id).emit(\"keyPairAssigned\", {\n            token: session.token,\n            username: newUser.username,\n            avatar: newUser.avatar\n          })\n        } else {\n          console.log(\"The User Doesn't Exist\");\n          return;\n        }\n      } else {\n        console.log(\"The Session Doesn't Exist\");\n        return;\n      }\n    } catch (err) {\n      console.log(err);\n    }\n  });\n\n  // Handle Token Validation requests\n  socket.on(\"validateToken\", async token => {\n    console.log(\"token\", token);\n    let session = await Session.findOne({ token });\n    if (session) {\n      console.log(\"The Session Exists\");\n      let user = await Usr.findById(session.user);\n      if (user) {\n        console.log(\"Token is Valid\");\n        // The Token is still Valid ===Emit(validToken)===> Client to validate the keyPair\n        let data = {\n          token: session.token,\n          avatar: user.avatar,\n          username: user.username,\n          publicKey: user.publicKey\n        }\n        // next step is RSA key validation\n        io.to(socket.id).emit(\"validToken\", data)\n        return;\n      } else {\n        console.log(\"The User Doesn't Exist\");\n        return;\n      }\n    } else {\n      console.log(\"TokenValidation:||:The Session Doesn't Exist\");\n      return;\n    }\n\n  });\n  // Send an Array of Images to the Profile page\n  socket.on(\"getImagesArray\", data => {\n    if (images.length === 5) {\n      Session.findOne({ token: data.token }, (err, session) => {\n        if (err) {\n          console.log(err);\n          return;\n        } else if (session !== null && session !== undefined) {\n          Usr.findById(session.user, (err, usr) => {\n            if (err) {\n              console.log(err);\n              return;\n            } else if (usr !== null && usr !== undefined) {\n              io.to(socket.id).emit(\"imagesArray\", images);\n            }\n          });\n        }\n      });\n    }\n  });\n  // Handle Profile Save\n  socket.on(\"saveProfile\", data => {\n    console.log(\"Received Image data\");\n    Session.findOne({ token: data.token }, (err, foundSession) => {\n      if (err) console.log(err);\n      else if (foundSession !== undefined && foundSession !== null) {\n        Usr.findById(foundSession.user, (err, foundUser) => {\n          if (err) {\n            console.log(err);\n            return;\n          } else if (foundUser !== null && foundUser !== undefined) {\n            const payload = {\n              token: foundSession.token,\n              username: foundUser.username,\n              avatar: foundUser.avatar\n            };\n            if (data.avatar === foundUser.avatar) {\n              io.to(socket.id).emit(\"profileSaved\", payload);\n              return;\n            } else {\n              foundUser.avatar = data.avatar;\n              foundUser.save((err, savedUser) => {\n                if (err) console.log(err);\n                else if (savedUser !== null && savedUser !== null) {\n                  const param = {\n                    token: foundSession.token,\n                    username: savedUser.username,\n                    avatar: savedUser.avatar\n                  };\n                  console.log(\"Saved profile\");\n                  io.to(socket.id).emit(\"profileSaved\", param);\n                }\n              });\n            }\n          }\n        });\n      }\n    });\n  }); // End of Saving Profile\n\n  // Handle Room Creation\n  socket.on(\"createRoom\", async data => {\n    let { token, name, avatar } = data; // roomName + token from the form\n    // Form Data Validation\n    if (name === null || name === undefined || name === \"\") {\n      io.to(socket.id).emit(\"groupFormError\", \"اكتب اسم المجموعة\");\n    } else if (name.length < 3 || name.length > 35) {\n      io.to(socket.id).emit(\"groupFormError\", \"يجب على الاسم ان يتكون من 3~35 حرف\");\n    } else {\n      try {\n        // The form is Authenticated\n        let session = await Session.findOne({ token });\n        if (session) {\n          let user = await Usr.findById(session.user);\n          if (user) {\n            let room = await Room.findOne({ name });\n            if (room) {\n              io.to(socket.id).emit(\"groupFormError\", \"the room name is taken\");\n            } else {\n              // Create a new Room Model\n              let newRoom = new Room({\n                name,\n                leader: user.username,\n                users: [user._id],\n                to: [user._id],\n                avatar: avatar === \"\" ? { uri: imgs[0].uri } : avatar\n              })\n              // Push the room to the user's rooms array\n              await user.rooms.push(newRoom._id);\n              // Save the models\n              let savedRoom = await newRoom.save();\n              let savedUser = await user.save();\n              // Emit the new room to the client\n              io.to(socket.id).emit(\"roomCreated\", savedRoom);\n              // Join the room\n              socket.join(newRoom.name);\n              console.log(`${savedUser.username} created ${savedRoom.name}`);\n\n            }\n          } else {\n            io.to(socket.id).emit(\"groupFormError\", \"failed to get the user for room creation\");\n          }\n        } else {\n          io.to(socket.id).emit(\"groupFormError\", \"failed to get the session for room creation\");\n        }\n      } catch (err) {\n        console.log(err);\n        return;\n      }\n    }\n  });\n  // Handle Fetching/joining the rooms\n  socket.on(\"getRooms\", async token => {\n    try {\n      let session = await Session.findOne({ token });\n      if (session) {\n        let user = await Usr.findById(session.user).populate(\"rooms\");\n        if (user) {\n          // emit the rooms to the client\n          io.to(socket.id).emit(\"rooms\", user.rooms);\n          // join the rooms\n          user.rooms.forEach(room => {\n            socket.join(room.name);\n          })\n          console.log(`${user.username} has ${user.rooms.length} rooms`);\n        } else {\n          console.log(\"the user doesn't exist\");\n          return;\n        }\n      } else {\n        console.log(\"the user isn't authenticated\");\n        return;\n      }\n    } catch (err) {\n      console.log(err);\n      return;\n    }\n  });\n  // Handle Logout , Delete Session\n  socket.on(\"logout\", data => {\n    console.log(`${data.username} is logging out`);\n    Session.findOne({ token: data.token }, (err, foundSession) => {\n      if (err) {\n        console.log(err);\n        return;\n      } else if (foundSession === null || foundSession === undefined) {\n        console.log(\"The Session Doesn't Exist\");\n        return;\n      } else {\n        foundSession.remove();\n        console.log(\"The Session is Removed\");\n        io.to(socket.id).emit(\"logedout\");\n      }\n    });\n  });\n\n  // Handle New Text Msgs\n  socket.on(\"newMsg\", async data => {\n    const { msg, token, roomName } = data;\n    try {\n      let session = await Session.findOne({ token });\n      if (session) {\n        let user = await Usr.findById(session.user);\n        if (user) {\n          let room = await Room.findOne({ name: roomName }).populate(\"users\", [\"publicKey\", \"username\"]);\n          console.log(\"newMsg[users]\", room.users.length);\n          // Initialization vector\n          let iv = randomBytes(8).toString(\"hex\");\n          // Symmetric encryption key AES 256bit/32bytes\n          let key = randomBytes(32).toString(\"hex\");\n          // Encrypted Bytes\n          let encrypted = AES.encrypt(msg, key, { iv: iv, mode: mode.CBC, padding: pad.Pkcs7 })\n          // CipherText\n          let cipherText = encrypted.toString();\n          console.log(\"cipher-text\", cipherText);\n          let buff = Buffer.from(key);\n          let from = user.username;\n          let to = []; // array of \n          if (room) {\n            room.users.forEach(usr => {\n              let encKey = publicEncrypt(\n                {\n                  key: usr.publicKey,\n                  padding: constants.RSA_PKCS1_PADDING\n                },\n                buff\n              ).toString(\"base64\");\n              to.push({\n                username: usr.username,\n                publicKey: usr.publicKey,\n                key: encKey\n              })\n            })\n            if (to.length === room.users.length) {\n              // Push the new Chat object to the chat array\n              room.chat.push({\n                iv, from, to,\n                isImg: false, msg: cipherText\n              })\n\n              let savedRoom = await room.save();\n              console.log(`${from} sent a msg to ${room.name}`);\n              io.to(savedRoom.name).emit(\"Msg\",\n                {\n                  msg: cipherText, to, iv,\n                  from, roomName: savedRoom.name\n                })\n            }\n          } else {\n            console.log(\"the room doesn't exist\");\n            return;\n          }\n        } else {\n          console.log(\"the user doesn't exist\");\n          return;\n        }\n      } else {\n        console.log(\"the user isn't authenticated\");\n        return;\n      }\n    } catch (err) {\n      console.log(err);\n      return;\n    }\n  });\n\n  // Handle Group Invitations ( group/room Leader ==Invites==> User)\n  socket.on(\"invite\", data => {\n    const { room, user, username } = data;\n    if (user === null || user === undefined || user === \"\") {\n      io.to(socket.id).emit(\"groupFormError\", \"اكتب اسم الشحص\");\n    } else if (user.length < 3 || user.length > 30) {\n      io.to(socket.id).emit(\"groupFormError\", \"يجب على الاسم أن يتكون من 3~35 حرف\");\n    } else {\n      Usr.findOne({ username: user }, (err, foundUser) => {\n        if (err) {\n          console.log(err);\n          return;\n        } else if (foundUser === null || foundUser === undefined) {\n          io.to(socket.id).emit(\"groupFormError\", \"لا يوجد هذا الشخص\");\n        } else {\n          Room.findOne({ name: room }, (err, foundRoom) => {\n            if (err) {\n              console.log(err);\n              return;\n            } else if (foundRoom === null || foundRoom === undefined) {\n              console.log(\"The Room doesn't Exist\");\n            } else {\n              if (foundRoom.leader === username) {\n                // The user is not in the room already\n                if (foundUser.rooms.indexOf(foundRoom._id) === -1) {\n                  // foundUser.rooms.push(foundRoom._id);\n                  // foundRoom.users.push(foundUser._id);\n                  let requestIndex = foundUser.requests.findIndex(request => request.roomName === foundRoom.name);\n                  if (requestIndex === -1) {\n                    foundUser.requests.push({ roomName: foundRoom.name, leader: foundRoom.leader })\n                    foundUser.save((err, savedUser) => {\n                      if (err) {\n                        console.log(err);\n                        return;\n                      } else {\n                        io.to(socket.id).emit(\"invited\");\n                        console.log(`Invited ${foundUser.username} ==room==> ${foundRoom.name} `);\n                      }\n                    });\n                  } else {\n                    io.to(socket.id).emit(\"groupFormError\", \"انتظر الشخص لكي يستجيب لدعوتك\");\n                  }\n\n                } else {\n                  io.to(socket.id).emit(\"groupFormError\", \"هذا الشخص عضو في المجموعة\");\n                }\n              } else {\n                console.log(\"you have to be the leader of the room to invite\");\n              }\n            }\n          });\n        }\n      });\n    }\n  });\n  // User Requests (Group Invitations from Group Leaders)\n  socket.on(\"getRequests\", token => {\n    Session.findOne({ token })\n      .then(session => {\n        if (session === null || session === undefined) {\n          console.log(\"The Session is Expired\");\n          return;\n        } else {\n          Usr.findById(session.user)\n            .then(user => {\n              if (user === null || user === undefined) {\n                console.log(\"The User is unavailable\");\n                return;\n              } else {\n                io.to(socket.id).emit(\"userRequests\", user.requests);\n                console.log(`Sent userRequests to ${user.username}`, user.requests);\n                return;\n              }\n            })\n        }\n      }).catch(err => console.log(err))\n  })\n\n  // Accept Invitation Requests to join a room\n  socket.on(\"acceptUserRequest\", data => {\n    let { token, roomName } = data;\n    Session.findOne({ token })\n      .then(session => {\n        if (session === null || session === undefined) {\n          console.log(\"The Session is Expired\");\n          return;\n        } else {\n          Usr.findById(session.user)\n            .then(user => {\n              if (user === null || user === undefined) {\n                console.log(\"The User is unavailable\");\n                return;\n              } else {\n                Room.findOne({ name: roomName })\n                  .then(room => {\n                    if (room === null || room === undefined) {\n                      console.log(\"The Room is unavailable\");\n                    } else {\n                      // Check if the user is already a member in the group/room\n                      let roomRefIndex = user.rooms.indexOf(room._id);\n                      console.log(\"refIndex\", roomRefIndex);\n                      if (roomRefIndex === -1) {\n                        // the user doesn't exist in the room\n                        room.users.push(user._id);\n                        user.rooms.push(room._id);\n                        let reqIndex = user.requests.findIndex(req => req.roomName === roomName);\n                        user.requests.splice(reqIndex, 1);\n                        room.save()\n                          .then(savedRoom => {\n                            user.save()\n                              .then(savedUser => {\n                                console.log(`${savedUser.username} joined ${savedRoom.name}`);\n                                socket.join(savedRoom.name);\n                                io.to(socket.id).emit(\"invitationAccepted\", savedRoom.name);\n                              }).catch(err => console.log(err));\n                          })\n                          .catch(err => console.log(err))\n                      } else {\n                        console.log(\"you are a member of this group\")\n                      }\n                    }\n                  })\n                  .catch(err => console.log(err))\n              }\n            })\n        }\n      }).catch(err => console.log(err))\n  })\n  // Refuse / Delete Invitation Request\n  socket.on(\"refuseUserRequest\", async (data) => {\n    let { token, roomName } = data;\n    try {\n      let session = await Session.findOne({ token });\n      if (session === null || session === undefined) {\n        console.log(\"The Session Doesn't Exist\");\n        return\n      } else {\n        let user = await Usr.findById(session.user);\n        if (user === null || user === undefined) {\n          console.log(\"The User Doesn't Exist\");\n          return\n        } else {\n          let reqIndex = await user.requests.findIndex(req => req.roomName === roomName);\n          await user.requests.splice(reqIndex, 1);\n          let savedUser = await user.save();\n          console.log(`A User Invitation Has Been Deleted`, savedUser.requests);\n          io.to(socket.id).emit(\"deletedUserRequest\", roomName);\n        }\n      }\n    } catch (err) {\n      console.log(err);\n    }\n  })\n  // Refuse / Delete Room Request (Requests sent from Users ===> Room Leaders)\n  socket.on(\"refuseRoomRequest\", async (data) => {\n    let { token, roomName, person } = data;\n    try {\n      let session = await Session.findOne({ token });\n      if (session === null || session === undefined) {\n        console.log(\"The Session Doesn't Exist\");\n        return\n      } else {\n        let user = await Usr.findById(session.user);\n        if (user === null || user === undefined) {\n          console.log(\"The User Doesn't Exist\");\n          return\n        } else {\n          let room = await Room.findOne({ name: roomName });\n          if (room) {\n            let requestIndex = room.requests.indexOf(person);\n            if (requestIndex !== -1) {\n              await room.requests.splice(requestIndex, 1);\n              await room.save();\n              io.to(socket.id).emit(\"roomRequestAccepted\", { person, roomName });\n            } else {\n              console.log(\"The Request Doesn't exist\");\n              return;\n            }\n          } else {\n            console.log(\"The room doesn't exist\");\n            return;\n          }\n        }\n      }\n    } catch (err) {\n      console.log(err);\n    }\n  })\n  // (Users Ask (Request) Room/Group Leader to join)\n  socket.on(\"joinRequest\", async (data) => {\n    const { token, name } = data;\n    // Input Validation\n    if (name === null || name === undefined || name === \"\") {\n      io.to(socket.id).emit(\"groupFormError\", \"اكتب اسم المجموعة\");\n    } else if (name.length < 3 || name.length > 35) {\n      io.to(socket.id).emit(\"groupFormError\", \"يجب على اسم المجموعة أن تتكون من 3~35 حرف\");\n    } else {\n      try {\n        let session = await Session.findOne({ token });\n        if (session === null || session === undefined) {\n          console.log(\"The Session is Expired\");\n          return;\n        } else {\n          let user = await Usr.findById(session.user);\n          if (user === null || user === undefined) {\n            console.log(\"The User doesn't exist\");\n            return;\n          } else {\n            let room = await Room.findOne({ name });\n            if (room === null || room === undefined) {\n              console.log(\"The Room doesn't exist\");\n              io.to(socket.id).emit(\"groupFormError\", \"لا توجد هذه مجموعة\");\n              return;\n            } else {\n              let reqIndex = await room.requests.indexOf(user.username);\n              let userIndex = await room.users.indexOf(user._id);\n              if (userIndex !== -1) {\n                io.to(socket.id).emit(\"groupFormError\", \"أنت عضو في هذه المجموعة\");\n              } else if (reqIndex === -1) {\n                await room.requests.push(user.username);\n                let savedRoom = await room.save();\n                console.log(`${user.username} ==Requests==> ${savedRoom.leader} to join ${savedRoom.name}`);\n                io.to(socket.id).emit(\"requestSent\");\n              } else {\n                console.log(\"The Request already exists\");\n                io.to(socket.id).emit(\"groupFormError\", \"انتظر الرد على طلب الدخول\");\n              }\n            }\n          }\n        }\n      } catch (err) {\n        console.log(err);\n      }\n    }\n  })\n\n  // Accept Room  Requests to join ( Normal User ==Requests== Room Leader)\n  socket.on(\"acceptRoomRequest\", async (data) => {\n    let { token, roomName, person } = data;\n    try {\n      // get the session by token\n      let session = await Session.findOne({ token });\n      if (!session) {\n        console.log(\"The Session Doesn't Exist\");\n        return\n      } else {\n        // check if the user exists\n        let user = await Usr.findById(session.user);\n        if (!user) {\n          console.log(\"The User Doesn't Exist\");\n          return\n        } else {\n          // get the person that you want to add to the room\n          let pers = await Usr.findOne({ username: person }); // person to add to the room\n          if (pers) {\n            // get the room by room name\n            let room = await Room.findOne({ name: roomName });\n            if (room) {\n              // Check if the user already exists in the room (This might never happen)\n              let personIndex = await room.users.indexOf(pers._id);\n              if (personIndex === -1) {\n                // the user doesn't exist in the room\n                await room.users.push(pers._id);\n                // find the request index to delete it\n                let reqIndex = await room.requests.indexOf(pers.username);\n                if (reqIndex !== -1) {\n                  await room.requests.splice(reqIndex, 1)\n                } else {\n                  console.log(\"The Request Doesn't Exist\");\n                }\n                let savedRoom = await room.save();\n                await pers.rooms.push(savedRoom._id);\n                pers.save();\n                console.log(`${savedRoom.leader} accepted ${pers.username}'s request to join ${room.name}`);\n                io.to(socket.id).emit(\"roomRequestAccepted\", { person: pers.username, roomName: savedRoom.name, id: pers._id });\n              } else {\n                console.log(`${pers.username} already exists in ${room.name}`);\n                return;\n              }\n            } else {\n              console.log(\"The Room Doesn't Exist\");\n              return;\n            }\n          } else {\n            // this happpens when an account is deleted \n            console.log(\"The Person you want to invite doesn't exist\")\n            return;\n          }\n        }\n      }\n    } catch (err) {\n      console.log(err);\n    }\n  })\n  socket.on(\"disconnect\", (reason) => {\n    console.log(`${socket.id} disconnected!!`);\n    console.log(`reason`, reason);\n  });\n});\n","module.exports = require(\"express\");","module.exports = require(\"morgan\");","module.exports = require(\"compression\");","module.exports = require(\"body-parser\");","module.exports = require(\"helmet\");","module.exports = require(\"cors\");","module.exports = require(\"dotenv\");","module.exports = require(\"socket.io\");","module.exports = require(\"http\");","module.exports = require(\"bcryptjs\");","import mongoose from \"mongoose\";\n\nconst UserSchema = new mongoose.Schema({\n  username: {\n    type: String,\n    required: true,\n    unique: true,\n    minlength: 3,\n    maxlength: 35\n  },\n  password: {\n    type: String,\n    required: true\n  },\n  publicKey: {\n    type: String,\n    required: true,\n    unique: true\n  },\n  session: {\n    type: mongoose.Schema.Types.ObjectId,\n    ref: \"Session\",\n    required: false\n  },\n  avatar: {},\n  rooms: {\n    type: [{ type: mongoose.Schema.Types.ObjectId, ref: \"Room\" }],\n    default: []\n  },\n  requests: { type: [{ roomName: String, leader: String }], default: [] },\n  createdAt: {\n    type: Date,\n    default: Date.now\n  }\n});\n\nexport default mongoose.model(\"User\", UserSchema);\n","import mongoose from \"mongoose\";\nconst SessionSchema = new mongoose.Schema({\n  createdAt: {\n    type: Date,\n    default: Date.now,\n    expires: \"1d\"\n  },\n  token: {\n    type: String,\n    unique: true\n  },\n  user: { type: mongoose.Schema.Types.ObjectId, ref: \"User\" }\n});\n\nexport default mongoose.model(\"Session\", SessionSchema);\n","import mongoose from \"mongoose\";\nconst RoomSchema = new mongoose.Schema({\n  createdAt: {\n    type: Date,\n    default: Date.now\n  },\n  name: {\n    type: String,\n    unique: true,\n    required: true,\n    minlength: 3,\n    maxlength: 35\n  },\n  avatar: {},\n  requests: { type: [String], default: [] },\n  users: [{ type: mongoose.Schema.Types.ObjectId, ref: \"User\" }],\n  leader: String,\n  chat: {\n    type: [\n      {\n        iv: String, // Hex encoded Initialization vector\n        msg: String, // base64 encoded , AES 256 Encrypted cipher text\n        from: String, // sender\n        to: [{\n          publicKey: String, // RSA public key string/pem\n          username: String,\n          key: String, // Base64 encoded ,AES 256 Encrypted Key\n        }],\n        isImg: Boolean,\n        createdAt: { type: Date, default: Date.now }\n      }\n    ],\n    default: []\n  }\n});\n\nexport default mongoose.model(\"Room\", RoomSchema);\n","module.exports = require(\"crypto\");","module.exports = require(\"crypto-js\");","module.exports = require(\"fs\");","module.exports = require(\"constants\");"],"sourceRoot":""}
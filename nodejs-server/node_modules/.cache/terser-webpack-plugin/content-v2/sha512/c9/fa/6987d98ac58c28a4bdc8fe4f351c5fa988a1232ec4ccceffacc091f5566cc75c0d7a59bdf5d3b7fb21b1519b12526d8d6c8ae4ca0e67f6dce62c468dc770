{"map":"{\"version\":3,\"sources\":[\"webpack/bootstrap\",\"external \\\"mongoose\\\"\",\"/home/ryan/E2E-Encrypted-Chat/nodejs-server/server.ts\",\"external \\\"express\\\"\",\"external \\\"morgan\\\"\",\"external \\\"compression\\\"\",\"external \\\"body-parser\\\"\",\"external \\\"helmet\\\"\",\"external \\\"cors\\\"\",\"external \\\"dotenv\\\"\",\"external \\\"socket.io\\\"\",\"external \\\"http\\\"\",\"external \\\"bcryptjs\\\"\",\"/home/ryan/E2E-Encrypted-Chat/nodejs-server/models/User.js\",\"/home/ryan/E2E-Encrypted-Chat/nodejs-server/models/Session.js\",\"/home/ryan/E2E-Encrypted-Chat/nodejs-server/models/Room.js\",\"external \\\"crypto\\\"\",\"external \\\"crypto-js\\\"\",\"external \\\"fs\\\"\",\"external \\\"constants\\\"\"],\"names\":[\"installedModules\",\"__webpack_require__\",\"moduleId\",\"exports\",\"module\",\"i\",\"l\",\"modules\",\"call\",\"m\",\"c\",\"d\",\"name\",\"getter\",\"o\",\"Object\",\"defineProperty\",\"enumerable\",\"get\",\"r\",\"Symbol\",\"toStringTag\",\"value\",\"t\",\"mode\",\"__esModule\",\"ns\",\"create\",\"key\",\"bind\",\"n\",\"object\",\"property\",\"prototype\",\"hasOwnProperty\",\"p\",\"s\",\"require\",\"express\",\"mongoose\",\"morgan\",\"compression\",\"bodyParser\",\"helmet\",\"cors\",\"dotenv_1\",\"IO\",\"http\",\"bcryptjs_1\",\"User_js_1\",\"Session_js_1\",\"Room_js_1\",\"crypto_1\",\"crypto_js_1\",\"fs_1\",\"constants\",\"console\",\"log\",\"images\",\"push\",\"uri\",\"readFileSync\",\"imgs\",\"config\",\"app\",\"use\",\"connect\",\"useNewUrlParser\",\"then\",\"process\",\"env\",\"USER\",\"catch\",\"err\",\"urlencoded\",\"extended\",\"json\",\"req\",\"res\",\"home\",\"success\",\"server\",\"createServer\",\"io\",\"listen\",\"PORT\",\"validateInputs\",\"data\",\"username\",\"password\",\"passwordc\",\"errors\",\"length\",\"isValid\",\"on\",\"socket\",\"id\",\"__awaiter\",\"this\",\"user\",\"default\",\"findOne\",\"to\",\"emit\",\"status\",\"authRefused\",\"publicKey\",\"salt\",\"genSalt\",\"passHashed\",\"hash\",\"userModel\",\"avatar\",\"findIndex\",\"img\",\"save\",\"compare\",\"token\",\"randomBytes\",\"toString\",\"session\",\"_id\",\"newSession\",\"newUser\",\"findById\",\"usr\",\"foundSession\",\"foundUser\",\"payload\",\"savedUser\",\"param\",\"newRoom\",\"leader\",\"users\",\"rooms\",\"savedRoom\",\"populate\",\"populated\",\"forEach\",\"room\",\"join\",\"remove\",\"msg\",\"roomName\",\"foundRoom\",\"iv\",\"cipherText\",\"AES\",\"encrypt\",\"CBC\",\"padding\",\"pad\",\"Pkcs7\",\"payloads\",\"buff\",\"Buffer\",\"from\",\"EncryptedKey\",\"publicEncrypt\",\"RSA_PKCS1_PADDING\",\"chat\",\"undefined\",\"isImage\",\"isImg\",\"indexOf\",\"requests\",\"request\",\"roomRefIndex\",\"reqIndex\",\"splice\",\"person\",\"requestIndex\",\"pers\",\"reason\",\"__webpack_exports__\",\"mongoose__WEBPACK_IMPORTED_MODULE_0__\",\"mongoose__WEBPACK_IMPORTED_MODULE_0___default\",\"UserSchema\",\"a\",\"Schema\",\"type\",\"String\",\"required\",\"unique\",\"minlength\",\"maxlength\",\"Types\",\"ObjectId\",\"ref\",\"createdAt\",\"Date\",\"now\",\"model\",\"SessionSchema\",\"expires\",\"RoomSchema\",\"Boolean\"],\"mappings\":\"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\",\"sourcesContent\":[\" \\t// The module cache\\n \\tvar installedModules = {};\\n\\n \\t// The require function\\n \\tfunction __webpack_require__(moduleId) {\\n\\n \\t\\t// Check if module is in cache\\n \\t\\tif(installedModules[moduleId]) {\\n \\t\\t\\treturn installedModules[moduleId].exports;\\n \\t\\t}\\n \\t\\t// Create a new module (and put it into the cache)\\n \\t\\tvar module = installedModules[moduleId] = {\\n \\t\\t\\ti: moduleId,\\n \\t\\t\\tl: false,\\n \\t\\t\\texports: {}\\n \\t\\t};\\n\\n \\t\\t// Execute the module function\\n \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n\\n \\t\\t// Flag the module as loaded\\n \\t\\tmodule.l = true;\\n\\n \\t\\t// Return the exports of the module\\n \\t\\treturn module.exports;\\n \\t}\\n\\n\\n \\t// expose the modules object (__webpack_modules__)\\n \\t__webpack_require__.m = modules;\\n\\n \\t// expose the module cache\\n \\t__webpack_require__.c = installedModules;\\n\\n \\t// define getter function for harmony exports\\n \\t__webpack_require__.d = function(exports, name, getter) {\\n \\t\\tif(!__webpack_require__.o(exports, name)) {\\n \\t\\t\\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\\n \\t\\t}\\n \\t};\\n\\n \\t// define __esModule on exports\\n \\t__webpack_require__.r = function(exports) {\\n \\t\\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\\n \\t\\t\\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\\n \\t\\t}\\n \\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n \\t};\\n\\n \\t// create a fake namespace object\\n \\t// mode & 1: value is a module id, require it\\n \\t// mode & 2: merge all properties of value into the ns\\n \\t// mode & 4: return value when already ns object\\n \\t// mode & 8|1: behave like require\\n \\t__webpack_require__.t = function(value, mode) {\\n \\t\\tif(mode & 1) value = __webpack_require__(value);\\n \\t\\tif(mode & 8) return value;\\n \\t\\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\\n \\t\\tvar ns = Object.create(null);\\n \\t\\t__webpack_require__.r(ns);\\n \\t\\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\\n \\t\\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\\n \\t\\treturn ns;\\n \\t};\\n\\n \\t// getDefaultExport function for compatibility with non-harmony modules\\n \\t__webpack_require__.n = function(module) {\\n \\t\\tvar getter = module && module.__esModule ?\\n \\t\\t\\tfunction getDefault() { return module['default']; } :\\n \\t\\t\\tfunction getModuleExports() { return module; };\\n \\t\\t__webpack_require__.d(getter, 'a', getter);\\n \\t\\treturn getter;\\n \\t};\\n\\n \\t// Object.prototype.hasOwnProperty.call\\n \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n\\n \\t// __webpack_public_path__\\n \\t__webpack_require__.p = \\\"\\\";\\n\\n\\n \\t// Load entry module and return exports\\n \\treturn __webpack_require__(__webpack_require__.s = 1);\\n\",\"module.exports = require(\\\"mongoose\\\");\",\"import * as express from \\\"express\\\";\\nimport * as mongoose from \\\"mongoose\\\";\\nimport * as morgan from \\\"morgan\\\";\\nimport * as compression from \\\"compression\\\";\\nimport * as bodyParser from \\\"body-parser\\\";\\nimport * as helmet from \\\"helmet\\\";\\nimport * as cors from \\\"cors\\\";\\nimport { config } from \\\"dotenv\\\";\\nimport * as IO from \\\"socket.io\\\";\\nimport { isEmpty } from \\\"lodash\\\";\\nimport * as http from \\\"http\\\";\\nimport { genSalt, hash, compare } from \\\"bcryptjs\\\";\\nimport Usr from \\\"./models/User.js\\\";\\nimport Session from \\\"./models/Session.js\\\";\\nimport Room from \\\"./models/Room.js\\\";\\nimport { randomBytes, createCipheriv, publicEncrypt, createCipher } from \\\"crypto\\\";\\nimport { mode, AES, enc, pad } from \\\"crypto-js\\\";\\nimport { readFileSync } from \\\"fs\\\";\\nvar constants = require(\\\"constants\\\");\\nconsole.log(constants);\\n// Read Images\\nlet images = [];\\nimages.push({\\n  name: \\\"Av1\\\",\\n  uri:\\n    \\\"data:image/png;base64,\\\" +\\n    readFileSync(\\\"./assets/avatar1.png\\\", \\\"base64\\\")\\n});\\nimages.push({\\n  name: \\\"Av2\\\",\\n  uri:\\n    \\\"data:image/png;base64,\\\" +\\n    readFileSync(\\\"./assets/avatar2.png\\\", \\\"base64\\\")\\n});\\nimages.push({\\n  name: \\\"Av3\\\",\\n  uri:\\n    \\\"data:image/png;base64,\\\" +\\n    readFileSync(\\\"./assets/avatar3.png\\\", \\\"base64\\\")\\n});\\nimages.push({\\n  name: \\\"Av4\\\",\\n  uri:\\n    \\\"data:image/png;base64,\\\" +\\n    readFileSync(\\\"./assets/avatar4.png\\\", \\\"base64\\\")\\n});\\nimages.push({\\n  name: \\\"Av5\\\",\\n  uri:\\n    \\\"data:image/png;base64,\\\" +\\n    readFileSync(\\\"./assets/avatar5.png\\\", \\\"base64\\\")\\n});\\n// Extra Images\\nlet imgs = [];\\nimgs.push({\\n  name: \\\"group\\\",\\n  uri:\\n    \\\"data:image/png;base64,\\\" +\\n    readFileSync(\\\"./assets/group.png\\\", \\\"base64\\\")\\n});\\nimgs.push({\\n  name: \\\"noAv\\\",\\n  uri:\\n    \\\"data:image/png;base64,\\\" +\\n    readFileSync(\\\"./assets/noavatar.jpeg\\\", \\\"base64\\\")\\n});\\n\\n// loads .env into process.env\\nconfig();\\n// // load keys\\n// const pkey = readFileSync('key.pem').toString(\\\"ascii\\\");\\n// const sig = createSign(\\\"RSA-SHA256\\\");\\n\\n// instantiating our server\\nconst app: express.Application = express();\\n\\n// protection layer\\napp.use(helmet());\\n// connect to mongoose / mongodb , returns a promise\\nmongoose\\n  .connect(\\n    \\\"mongodb://localhost:27017/Chat\\\",\\n    { useNewUrlParser: true }\\n  )\\n  .then(() => console.log(`${process.env.USER} Connected to MongoDB `))\\n  .catch(err => console.log(err));\\n\\n// parse application/json\\napp.use(bodyParser.urlencoded({ extended: false }));\\napp.use(bodyParser.json());\\n// cross-origin resource sharing\\napp.use(cors());\\n// prod mode\\napp.use(compression());\\napp.use(morgan(\\\"common\\\"));\\n\\napp.get(\\\"/\\\", (req, res) => {\\n  res.json({ home: \\\"Key generation route\\\" });\\n});\\napp.get(\\\"**\\\", (req, res) => {\\n  res.json({ success: \\\"Hello world from express\\\" });\\n});\\n\\ntype User = {\\n  username?: string;\\n  password?: string;\\n  passwordc?: string;\\n  public_key?: string;\\n};\\n\\nconst server = http.createServer(app);\\nconst io = IO(server);\\nserver.listen(process.env.PORT, () => {\\n  console.log(`Express Server on port: ${process.env.PORT}`);\\n});\\n\\n// Form Validation Function\\nconst validateInputs = (data: User) => {\\n  // Destructuring for better readability\\n  const { username, password, passwordc } = data;\\n  // initialize an errors object\\n  let errors: User = { username: \\\"\\\", password: \\\"\\\", passwordc: \\\"\\\" };\\n  // validate the username\\n  if (username === null || username === undefined || username === \\\"\\\") {\\n    errors.username = \\\"the username is a required field\\\";\\n  } else if (username.length < 3 || username.length > 35) {\\n    errors.username = \\\"يجب على الاسم أن يتكون من 3~35 حرف\\\";\\n  }\\n  // validate the password\\n  if (password === null || password === undefined || password === \\\"\\\") {\\n    errors.password = \\\"the password is a required field\\\";\\n  } else if (password.length < 8 || password.length > 35) {\\n    errors.password = \\\"the password must be 8~35 characters\\\";\\n  } else if (\\n    passwordc !== undefined &&\\n    passwordc !== null &&\\n    passwordc !== password\\n  ) {\\n    errors.passwordc = \\\"the two passwords must be equal\\\";\\n  }\\n  // if the input form doesn't have password confirmation , delete the error\\n  if (passwordc === null || passwordc === undefined) {\\n    delete errors.passwordc;\\n    if (errors.password + errors.username === \\\"\\\") {\\n      return { isValid: true, errors };\\n    } else {\\n      return { isValid: false, errors };\\n    }\\n  }\\n\\n  if (errors.password + errors.passwordc + errors.username === \\\"\\\") {\\n    return { isValid: true, errors };\\n  } else {\\n    return { isValid: false, errors };\\n  }\\n};\\n\\nio.on(\\\"connection\\\", socket => {\\n  console.log(`socket: ${socket.id} connected`);\\n\\n  // ~~~ User Registeration Validation ~~~ //\\n  socket.on(\\\"validateRegister\\\", async (data: User) => {\\n    // Server Side Validation Function\\n    let { errors, isValid } = validateInputs(data);\\n    // Check if the input form is valid\\n    if (isValid) {\\n      try {\\n        // Check If The User Exists\\n        let user = await Usr.findOne({ username: data.username });\\n        if (user) {\\n          errors.passwordc = `${user.username} is used by another user`;\\n          io.to(socket.id).emit(\\\"status\\\", {\\n            status: `${user.username} is used by another user`,\\n            errors\\n          })\\n          return\\n        } else {\\n          // Emit to the client that the form is valid.. \\n          // to generate the RSA keyPair on the client\\n          io.to(socket.id).emit(\\\"validatedInput\\\", data.username);\\n          return;\\n        }\\n      } catch (err) {\\n        console.log(err);\\n        return;\\n      }\\n    } else {\\n      io.to(socket.id).emit(\\\"status\\\", {\\n        status: `${socket.id}'s reg-form is invalid`,\\n        errors\\n      });\\n      console.log({\\n        authRefused: `${socket.id}'s reg-form is invalid`,\\n        errors\\n      });\\n    }\\n  }); // End of User Registeration Validation <===\\n\\n  //  Handle User Registeration after the... \\n  //  Server Validation + Client RSA Key Generation\\n  socket.on(\\\"register\\\", async (data) => {\\n    let { password, username, publicKey } = data;\\n    // At this point we assume that the inputs are valid\\n    // Generate a salt ==> hash the password ==> create a new user\\n    try {\\n      let salt = await genSalt(10);\\n      let passHashed = await hash(password, salt)\\n      const userModel = new Usr({\\n        username: username,\\n        password: passHashed,\\n        publicKey: publicKey,\\n        avatar: imgs[await imgs.findIndex(img => img.name === \\\"noAv\\\")]\\n      });\\n      await userModel.save();\\n      io.to(socket.id).emit(\\\"registered\\\");\\n    } catch (err) {\\n      console.log(err);\\n      return;\\n    }\\n\\n  });\\n\\n  // Manage Login Requests\\n  socket.on(\\\"loginRequest\\\", async data => {\\n    let { username, password } = data;\\n    console.log(`${username} is trying to login`);\\n    const { isValid, errors } = validateInputs(data);\\n    // first validation\\n    if (isValid) {\\n      try {\\n        let user = await Usr.findOne({ username });\\n        if (user) {\\n          // The user exists , compare the password with the saved hash\\n          let passValid = await compare(password, user.password);\\n          if (passValid) {\\n            // The password is valid = The user is authenticated\\n            // Generate Authentication Token\\n            let token = await randomBytes(32).toString(\\\"hex\\\");\\n            // Create a new Session Model to store the new token\\n            let session = await new Session({\\n              token,\\n              user: user._id\\n            })\\n            // Mutate the User's Model to add the new Session's Id\\n            user.session = session._id;\\n            // Save The mutated/new Models\\n            let newSession = await session.save();\\n            let newUser = await user.save();\\n            // Emit data to the client\\n            io.to(socket.id).emit(\\\"token\\\", {\\n              token: newSession.token,\\n              publicKey: newUser.publicKey,\\n              avatar: newUser.avatar,\\n              username: newUser.username,\\n            })\\n          } else {\\n            // The password is Invalid \\n            errors.password = \\\"The password is invalid\\\";\\n            io.to(socket.id).emit(\\\"status\\\", { status: \\\"The password is Invalid\\\", errors })\\n            return;\\n          }\\n        } else {\\n          // The user doesn't exist in the database\\n          errors.password = \\\"The user doesn't exist\\\"\\n          console.log(\\\"the user doesn't exist\\\");\\n          io.to(socket.id).emit(\\\"status\\\", { status: \\\"The user doesn't exist\\\", errors })\\n          return;\\n        }\\n\\n      } catch (err) {\\n        console.log(err)\\n      }\\n    } else {\\n      // The Registeration Form is Invalid\\n      io.to(socket.id).emit(\\\"status\\\", { status: \\\"invalid registeration form\\\", errors })\\n      return;\\n    }\\n  })\\n\\n\\n  // Assigning new public key's to current users\\n  socket.on(\\\"assignKey\\\", async data => {\\n    console.log(\\\"Assigning a new key\\\");\\n    let { token, username, publicKey } = data;\\n    try {\\n      let session = await Session.findOne({ token });\\n      if (session) {\\n        // The Session Exists\\n        let user = await Usr.findById(session.user);\\n        if (user) {\\n          user.publicKey = publicKey;\\n          let newUser = await user.save();\\n          io.to(socket.id).emit(\\\"keyPairAssigned\\\", {\\n            token: session.token,\\n            username: newUser.username,\\n            avatar: newUser.avatar\\n          })\\n        } else {\\n          console.log(\\\"The User Doesn't Exist\\\");\\n          return;\\n        }\\n      } else {\\n        console.log(\\\"The Session Doesn't Exist\\\");\\n        return;\\n      }\\n    } catch (err) {\\n      console.log(err);\\n    }\\n  });\\n\\n  // Handle Token Validation requests\\n  socket.on(\\\"validateToken\\\", async token => {\\n    console.log(\\\"token\\\", token);\\n    let session = await Session.findOne({ token });\\n    if (session) {\\n      console.log(\\\"The Session Exists\\\");\\n      let user = await Usr.findById(session.user);\\n      if (user) {\\n        console.log(\\\"Token is Valid\\\");\\n        // The Token is still Valid ===Emit(validToken)===> Client to validate the keyPair\\n        let data = {\\n          token: session.token,\\n          avatar: user.avatar,\\n          username: user.username,\\n          publicKey: user.publicKey\\n        }\\n        // next step is RSA key validation\\n        io.to(socket.id).emit(\\\"validToken\\\", data)\\n        return;\\n      } else {\\n        console.log(\\\"The User Doesn't Exist\\\");\\n        return;\\n      }\\n    } else {\\n      console.log(\\\"TokenValidation:||:The Session Doesn't Exist\\\");\\n      return;\\n    }\\n\\n  });\\n  // Send an Array of Images to the Profile page\\n  socket.on(\\\"getImagesArray\\\", data => {\\n    if (images.length === 5) {\\n      Session.findOne({ token: data.token }, (err, session) => {\\n        if (err) {\\n          console.log(err);\\n          return;\\n        } else if (session !== null && session !== undefined) {\\n          Usr.findById(session.user, (err, usr) => {\\n            if (err) {\\n              console.log(err);\\n              return;\\n            } else if (usr !== null && usr !== undefined) {\\n              io.to(socket.id).emit(\\\"imagesArray\\\", images);\\n            }\\n          });\\n        }\\n      });\\n    }\\n  });\\n  // Handle Profile Save\\n  socket.on(\\\"saveProfile\\\", data => {\\n    console.log(\\\"Received Image data\\\");\\n    Session.findOne({ token: data.token }, (err, foundSession) => {\\n      if (err) console.log(err);\\n      else if (foundSession !== undefined && foundSession !== null) {\\n        Usr.findById(foundSession.user, (err, foundUser) => {\\n          if (err) {\\n            console.log(err);\\n            return;\\n          } else if (foundUser !== null && foundUser !== undefined) {\\n            const payload = {\\n              token: foundSession.token,\\n              username: foundUser.username,\\n              avatar: foundUser.avatar\\n            };\\n            if (data.avatar === foundUser.avatar) {\\n              io.to(socket.id).emit(\\\"profileSaved\\\", payload);\\n              return;\\n            } else {\\n              foundUser.avatar = data.avatar;\\n              foundUser.save((err, savedUser) => {\\n                if (err) console.log(err);\\n                else if (savedUser !== null && savedUser !== null) {\\n                  const param = {\\n                    token: foundSession.token,\\n                    username: savedUser.username,\\n                    avatar: savedUser.avatar\\n                  };\\n                  console.log(\\\"Saved profile\\\");\\n                  io.to(socket.id).emit(\\\"profileSaved\\\", param);\\n                }\\n              });\\n            }\\n          }\\n        });\\n      }\\n    });\\n  }); // End of Saving Profile\\n\\n  // Handle Room Creation\\n  socket.on(\\\"createRoom\\\", async data => {\\n    let { token, name } = data; // roomName + token from the form\\n    // Form Data Validation\\n    if (name === null || name === undefined || name === \\\"\\\") {\\n      io.to(socket.id).emit(\\\"groupFormError\\\", \\\"اكتب اسم المجموعة\\\");\\n    } else if (name.length < 3 || name.length > 35) {\\n      io.to(socket.id).emit(\\\"groupFormError\\\", \\\"يجب على الاسم ان يتكون من 3~35 حرف\\\");\\n    } else {\\n      try {\\n        // The form is Authenticated\\n        let session = await Session.findOne({ token });\\n        if (session) {\\n          let user = await Usr.findById(session.user);\\n          if (user) {\\n            let room = await Room.findOne({ name });\\n            if (room) {\\n              io.to(socket.id).emit(\\\"groupFormError\\\", \\\"the room name is taken\\\");\\n            } else {\\n              // Create a new Room Model\\n              let newRoom = new Room({\\n                name,\\n                leader: user.username,\\n                users: [user._id],\\n              })\\n              // Push the room to the user's rooms array\\n              await user.rooms.push(newRoom._id);\\n              // Save the models\\n              let savedRoom = await newRoom.save();\\n              let savedUser = await user.save();\\n              io.to(socket.id).emit(\\\"roomCreated\\\", savedRoom);\\n              console.log(`${savedUser.username} created ${savedRoom.name}`);\\n\\n            }\\n          } else {\\n            io.to(socket.id).emit(\\\"groupFormError\\\", \\\"failed to get the user for room creation\\\");\\n          }\\n        } else {\\n          io.to(socket.id).emit(\\\"groupFormError\\\", \\\"failed to get the session for room creation\\\");\\n        }\\n      } catch (err) {\\n        console.log(err);\\n        return;\\n      }\\n    }\\n  });\\n  // Handle Fetching/joining the rooms\\n  socket.on(\\\"getRooms\\\", token => {\\n    console.log(token);\\n    Session.findOne({ token: token }, (err, foundSession) => {\\n      if (err) {\\n        console.log(err);\\n        return;\\n      } else if (foundSession === null || foundSession === undefined) {\\n        console.log(\\\"The Session Doesn't Exists\\\");\\n        return;\\n      } else {\\n        Usr.findById(foundSession.user, [\\\"rooms\\\", \\\"username\\\"])\\n          .then(foundUser => {\\n            foundUser.populate(\\\"rooms\\\", (err, populated) => {\\n              populated.rooms.forEach((room, i) => {\\n                console.log(room);\\n                socket.join(room.name);\\n                console.log(\\\"Joined\\\", room.name);\\n              });\\n              io.to(socket.id).emit(\\\"rooms\\\", populated.rooms);\\n            });\\n          })\\n          .catch(err => console.log(err));\\n      }\\n    });\\n  });\\n  // Handle Logout , Delete Session\\n  socket.on(\\\"logout\\\", data => {\\n    console.log(`${data.username} is logging out`);\\n    Session.findOne({ token: data.token }, (err, foundSession) => {\\n      if (err) {\\n        console.log(err);\\n        return;\\n      } else if (foundSession === null || foundSession === undefined) {\\n        console.log(\\\"The Session Doesn't Exist\\\");\\n        return;\\n      } else {\\n        foundSession.remove();\\n        console.log(\\\"The Session is Removed\\\");\\n        io.to(socket.id).emit(\\\"logedout\\\");\\n      }\\n    });\\n  });\\n\\n  // Handle New Text Msgs\\n  socket.on(\\\"newMsg\\\", data => {\\n    const { msg, token, roomName } = data;\\n    Session.findOne({ token: token }, (err, foundSession) => {\\n      if (err) {\\n        console.log(err);\\n        return;\\n      } else if (foundSession === null || foundSession === undefined) {\\n        console.log(\\\"the token is expired\\\");\\n      } else {\\n        Usr.findById(foundSession.user)\\n          .then(foundUser => {\\n            if (foundUser === null || foundUser === undefined) {\\n              console.log(\\\"The User Doesn't Exist\\\");\\n              return;\\n            } else {\\n              Room.findOne({ name: roomName })\\n                .populate(\\\"users\\\", [\\\"publicKey\\\", \\\"username\\\"])\\n                .then(foundRoom => {\\n                  if (foundRoom === null || foundRoom === undefined) {\\n                    console.log(\\\"the room doesn't exist\\\");\\n                    return;\\n                  } else {\\n                    // Initialization vector\\n                    let iv = randomBytes(8).toString(\\\"hex\\\");\\n                    // Symmetric encryption key AES 256bit/32bytes\\n                    let key = randomBytes(32).toString(\\\"hex\\\");\\n                    // Encrypted Bytes\\n                    let encrypted = AES.encrypt(msg, key, { iv: iv, mode: mode.CBC, padding: pad.Pkcs7 })\\n                    // CipherText\\n                    let cipherText = encrypted.toString();\\n                    console.log(\\\"cipher-text\\\", cipherText);\\n                    let payloads = []; // each user in the room has an encrypted payload\\n                    let buff = Buffer.from(key);\\n                    let from = foundUser.username;\\n                    let to = []; // array of \\n                    foundRoom.users.forEach((user, i) => {\\n                      let EncryptedKey = publicEncrypt(\\n                        {\\n                          key: user.publicKey,\\n                          padding: constants.RSA_PKCS1_PADDING\\n                        },\\n                        buff\\n                      ).toString(\\\"base64\\\");\\n                      payloads.push({\\n                        roomName: foundRoom.name,\\n                        from: foundUser.username,\\n                        msg: cipherText,\\n                        key: EncryptedKey,\\n                        publicKey: user.publicKey,\\n                        iv\\n                      });\\n                      to.push({\\n                        publicKey: user.publicKey,\\n                        key: EncryptedKey,\\n                        username: user.username\\n                      });\\n                    });\\n                    if (\\n                      foundRoom.chat === null ||\\n                      foundRoom.chat === undefined ||\\n                      foundRoom.chat.length === 0\\n                    ) {\\n                      foundRoom.chat = [\\n                        { from, to, msg: cipherText, isImage: false, iv }\\n                      ];\\n                    } else {\\n                      foundRoom.chat.push({\\n                        from, to, msg: cipherText, isImg: false, iv\\n                      });\\n                    }\\n                    foundRoom.save()\\n                      .then(savedRoom => {\\n                        console.log(\\\"Saved Room\\\", savedRoom.name);\\n                        console.log(payloads);\\n                        io.to(savedRoom.name).emit(\\\"Msg\\\", payloads);\\n                      })\\n                      .catch(err => console.log(err));\\n\\n                  }\\n                })\\n                .catch(err => console.log(err));\\n            }\\n          })\\n          .catch(err => console.log(err));\\n      }\\n    });\\n  });\\n\\n  // Handle Group Invitations ( group/room Leader ==Invites==> User)\\n  socket.on(\\\"invite\\\", data => {\\n    const { room, user, username } = data;\\n    if (user === null || user === undefined || user === \\\"\\\") {\\n      io.to(socket.id).emit(\\\"groupFormError\\\", \\\"اكتب اسم الشحص\\\");\\n    } else if (user.length < 3 || user.length > 30) {\\n      io.to(socket.id).emit(\\\"groupFormError\\\", \\\"يجب على الاسم أن يتكون من 3~35 حرف\\\");\\n    } else {\\n      Usr.findOne({ username: user }, (err, foundUser) => {\\n        if (err) {\\n          console.log(err);\\n          return;\\n        } else if (foundUser === null || foundUser === undefined) {\\n          io.to(socket.id).emit(\\\"groupFormError\\\", \\\"لا يوجد هذا الشخص\\\");\\n        } else {\\n          Room.findOne({ name: room }, (err, foundRoom) => {\\n            if (err) {\\n              console.log(err);\\n              return;\\n            } else if (foundRoom === null || foundRoom === undefined) {\\n              console.log(\\\"The Room doesn't Exist\\\");\\n            } else {\\n              if (foundRoom.leader === username) {\\n                // The user is not in the room already\\n                if (foundUser.rooms.indexOf(foundRoom._id) === -1) {\\n                  // foundUser.rooms.push(foundRoom._id);\\n                  // foundRoom.users.push(foundUser._id);\\n                  let requestIndex = foundUser.requests.findIndex(request => request.roomName === foundRoom.name);\\n                  if (requestIndex === -1) {\\n                    foundUser.requests.push({ roomName: foundRoom.name, leader: foundRoom.leader })\\n                    foundUser.save((err, savedUser) => {\\n                      if (err) {\\n                        console.log(err);\\n                        return;\\n                      } else {\\n                        io.to(socket.id).emit(\\\"invited\\\");\\n                        console.log(`Invited ${foundUser.username} ==room==> ${foundRoom.name} `);\\n                      }\\n                    });\\n                  } else {\\n                    io.to(socket.id).emit(\\\"groupFormError\\\", \\\"انتظر الشخص لكي يستجيب لدعوتك\\\");\\n                  }\\n\\n                } else {\\n                  io.to(socket.id).emit(\\\"groupFormError\\\", \\\"هذا الشخص عضو في المجموعة\\\");\\n                }\\n              } else {\\n                console.log(\\\"you have to be the leader of the room to invite\\\");\\n              }\\n            }\\n          });\\n        }\\n      });\\n    }\\n  });\\n  // User Requests (Group Invitations from Group Leaders)\\n  socket.on(\\\"getRequests\\\", token => {\\n    Session.findOne({ token })\\n      .then(session => {\\n        if (session === null || session === undefined) {\\n          console.log(\\\"The Session is Expired\\\");\\n          return;\\n        } else {\\n          Usr.findById(session.user)\\n            .then(user => {\\n              if (user === null || user === undefined) {\\n                console.log(\\\"The User is unavailable\\\");\\n                return;\\n              } else {\\n                io.to(socket.id).emit(\\\"userRequests\\\", user.requests);\\n                console.log(`Sent userRequests to ${user.username}`, user.requests);\\n                return;\\n              }\\n            })\\n        }\\n      }).catch(err => console.log(err))\\n  })\\n\\n  // Accept Invitation Requests to join a room\\n  socket.on(\\\"acceptUserRequest\\\", data => {\\n    let { token, roomName } = data;\\n    Session.findOne({ token })\\n      .then(session => {\\n        if (session === null || session === undefined) {\\n          console.log(\\\"The Session is Expired\\\");\\n          return;\\n        } else {\\n          Usr.findById(session.user)\\n            .then(user => {\\n              if (user === null || user === undefined) {\\n                console.log(\\\"The User is unavailable\\\");\\n                return;\\n              } else {\\n                Room.findOne({ name: roomName })\\n                  .then(room => {\\n                    if (room === null || room === undefined) {\\n                      console.log(\\\"The Room is unavailable\\\");\\n                    } else {\\n                      // Check if the user is already a member in the group/room\\n                      let roomRefIndex = user.rooms.indexOf(room._id);\\n                      console.log(\\\"refIndex\\\", roomRefIndex);\\n                      if (roomRefIndex === -1) {\\n                        // the user doesn't exist in the room\\n                        room.users.push(user._id);\\n                        user.rooms.push(room._id);\\n                        let reqIndex = user.requests.findIndex(req => req.roomName === roomName);\\n                        user.requests.splice(reqIndex, 1);\\n                        room.save()\\n                          .then(savedRoom => {\\n                            user.save()\\n                              .then(savedUser => {\\n                                console.log(`${savedUser.username} joined ${savedRoom.name}`);\\n                                socket.join(savedRoom.name);\\n                                io.to(socket.id).emit(\\\"invitationAccepted\\\", savedRoom.name);\\n                              }).catch(err => console.log(err));\\n                          })\\n                          .catch(err => console.log(err))\\n                      } else {\\n                        console.log(\\\"you are a member of this group\\\")\\n                      }\\n                    }\\n                  })\\n                  .catch(err => console.log(err))\\n              }\\n            })\\n        }\\n      }).catch(err => console.log(err))\\n  })\\n  // Refuse / Delete Invitation Request\\n  socket.on(\\\"refuseUserRequest\\\", async (data) => {\\n    let { token, roomName } = data;\\n    try {\\n      let session = await Session.findOne({ token });\\n      if (session === null || session === undefined) {\\n        console.log(\\\"The Session Doesn't Exist\\\");\\n        return\\n      } else {\\n        let user = await Usr.findById(session.user);\\n        if (user === null || user === undefined) {\\n          console.log(\\\"The User Doesn't Exist\\\");\\n          return\\n        } else {\\n          let reqIndex = await user.requests.findIndex(req => req.roomName === roomName);\\n          await user.requests.splice(reqIndex, 1);\\n          let savedUser = await user.save();\\n          console.log(`A User Invitation Has Been Deleted`, savedUser.requests);\\n          io.to(socket.id).emit(\\\"deletedUserRequest\\\", roomName);\\n        }\\n      }\\n    } catch (err) {\\n      console.log(err);\\n    }\\n  })\\n  // Refuse / Delete Room Request (Requests sent from Users ===> Room Leaders)\\n  socket.on(\\\"refuseRoomRequest\\\", async (data) => {\\n    let { token, roomName, person } = data;\\n    try {\\n      let session = await Session.findOne({ token });\\n      if (session === null || session === undefined) {\\n        console.log(\\\"The Session Doesn't Exist\\\");\\n        return\\n      } else {\\n        let user = await Usr.findById(session.user);\\n        if (user === null || user === undefined) {\\n          console.log(\\\"The User Doesn't Exist\\\");\\n          return\\n        } else {\\n          let room = await Room.findOne({ name: roomName });\\n          if (room) {\\n            let requestIndex = room.requests.indexOf(person);\\n            if (requestIndex !== -1) {\\n              await room.requests.splice(requestIndex, 1);\\n              await room.save();\\n              io.to(socket.id).emit(\\\"roomRequestAccepted\\\", { person, roomName });\\n            } else {\\n              console.log(\\\"The Request Doesn't exist\\\");\\n              return;\\n            }\\n          } else {\\n            console.log(\\\"The room doesn't exist\\\");\\n            return;\\n          }\\n        }\\n      }\\n    } catch (err) {\\n      console.log(err);\\n    }\\n  })\\n  // (Users Ask (Request) Room/Group Leader to join)\\n  socket.on(\\\"joinRequest\\\", async (data) => {\\n    const { token, name } = data;\\n    // Input Validation\\n    if (name === null || name === undefined || name === \\\"\\\") {\\n      io.to(socket.id).emit(\\\"groupFormError\\\", \\\"اكتب اسم المجموعة\\\");\\n    } else if (name.length < 3 || name.length > 35) {\\n      io.to(socket.id).emit(\\\"groupFormError\\\", \\\"يجب على اسم المجموعة أن تتكون من 3~35 حرف\\\");\\n    } else {\\n      try {\\n        let session = await Session.findOne({ token });\\n        if (session === null || session === undefined) {\\n          console.log(\\\"The Session is Expired\\\");\\n          return;\\n        } else {\\n          let user = await Usr.findById(session.user);\\n          if (user === null || user === undefined) {\\n            console.log(\\\"The User doesn't exist\\\");\\n            return;\\n          } else {\\n            let room = await Room.findOne({ name });\\n            if (room === null || room === undefined) {\\n              console.log(\\\"The Room doesn't exist\\\");\\n              io.to(socket.id).emit(\\\"groupFormError\\\", \\\"لا توجد هذه مجموعة\\\");\\n              return;\\n            } else {\\n              let reqIndex = await room.requests.indexOf(user.username);\\n              let userIndex = await room.users.indexOf(user._id);\\n              if (userIndex !== -1) {\\n                io.to(socket.id).emit(\\\"groupFormError\\\", \\\"أنت عضو في هذه المجموعة\\\");\\n              } else if (reqIndex === -1) {\\n                await room.requests.push(user.username);\\n                let savedRoom = await room.save();\\n                console.log(`${user.username} ==Requests==> ${savedRoom.leader} to join ${savedRoom.name}`);\\n                io.to(socket.id).emit(\\\"requestSent\\\");\\n              } else {\\n                console.log(\\\"The Request already exists\\\");\\n                io.to(socket.id).emit(\\\"groupFormError\\\", \\\"انتظر الرد على طلب الدخول\\\");\\n              }\\n            }\\n          }\\n        }\\n      } catch (err) {\\n        console.log(err);\\n      }\\n    }\\n  })\\n\\n  // Accept Room  Requests to join ( Normal User ==Requests== Room Leader)\\n  socket.on(\\\"acceptRoomRequest\\\", async (data) => {\\n    let { token, roomName, person } = data;\\n    try {\\n      // get the session by token\\n      let session = await Session.findOne({ token });\\n      if (!session) {\\n        console.log(\\\"The Session Doesn't Exist\\\");\\n        return\\n      } else {\\n        // check if the user exists\\n        let user = await Usr.findById(session.user);\\n        if (!user) {\\n          console.log(\\\"The User Doesn't Exist\\\");\\n          return\\n        } else {\\n          // get the person that you want to add to the room\\n          let pers = await Usr.findOne({ username: person }); // person to add to the room\\n          if (pers) {\\n            // get the room by room name\\n            let room = await Room.findOne({ name: roomName });\\n            if (room) {\\n              // Check if the user already exists in the room (This might never happen)\\n              let personIndex = await room.users.indexOf(pers._id);\\n              if (personIndex === -1) {\\n                // the user doesn't exist in the room\\n                await room.users.push(pers._id);\\n                // find the request index to delete it\\n                let reqIndex = await room.requests.indexOf(pers.username);\\n                if (reqIndex !== -1) {\\n                  await room.requests.splice(reqIndex, 1)\\n                } else {\\n                  console.log(\\\"The Request Doesn't Exist\\\");\\n                }\\n                let savedRoom = await room.save();\\n                await pers.rooms.push(savedRoom._id);\\n                pers.save();\\n                console.log(`${savedRoom.leader} accepted ${pers.username}'s request to join ${room.name}`);\\n                io.to(socket.id).emit(\\\"roomRequestAccepted\\\", { person: pers.username, roomName: savedRoom.name, id: pers._id });\\n              } else {\\n                console.log(`${pers.username} already exists in ${room.name}`);\\n                return;\\n              }\\n            } else {\\n              console.log(\\\"The Room Doesn't Exist\\\");\\n              return;\\n            }\\n          } else {\\n            // this happpens when an account is deleted \\n            console.log(\\\"The Person you want to invite doesn't exist\\\")\\n            return;\\n          }\\n        }\\n      }\\n    } catch (err) {\\n      console.log(err);\\n    }\\n  })\\n  socket.on(\\\"disconnect\\\", (reason) => {\\n    console.log(`${socket.id} disconnected!!`);\\n    console.log(`reason`, reason);\\n  });\\n});\\n\",\"module.exports = require(\\\"express\\\");\",\"module.exports = require(\\\"morgan\\\");\",\"module.exports = require(\\\"compression\\\");\",\"module.exports = require(\\\"body-parser\\\");\",\"module.exports = require(\\\"helmet\\\");\",\"module.exports = require(\\\"cors\\\");\",\"module.exports = require(\\\"dotenv\\\");\",\"module.exports = require(\\\"socket.io\\\");\",\"module.exports = require(\\\"http\\\");\",\"module.exports = require(\\\"bcryptjs\\\");\",\"import mongoose from \\\"mongoose\\\";\\n\\nconst UserSchema = new mongoose.Schema({\\n  username: {\\n    type: String,\\n    required: true,\\n    unique: true,\\n    minlength: 3,\\n    maxlength: 35\\n  },\\n  password: {\\n    type: String,\\n    required: true\\n  },\\n  publicKey: {\\n    type: String,\\n    required: true,\\n    unique: true\\n  },\\n  session: {\\n    type: mongoose.Schema.Types.ObjectId,\\n    ref: \\\"Session\\\",\\n    required: false\\n  },\\n  avatar: {},\\n  rooms: {\\n    type: [{ type: mongoose.Schema.Types.ObjectId, ref: \\\"Room\\\" }],\\n    default: []\\n  },\\n  requests: { type: [{ roomName: String, leader: String }], default: [] },\\n  createdAt: {\\n    type: Date,\\n    default: Date.now\\n  }\\n});\\n\\nexport default mongoose.model(\\\"User\\\", UserSchema);\\n\",\"import mongoose from \\\"mongoose\\\";\\nconst SessionSchema = new mongoose.Schema({\\n  createdAt: {\\n    type: Date,\\n    default: Date.now,\\n    expires: \\\"1d\\\"\\n  },\\n  token: {\\n    type: String,\\n    unique: true\\n  },\\n  user: { type: mongoose.Schema.Types.ObjectId, ref: \\\"User\\\" }\\n});\\n\\nexport default mongoose.model(\\\"Session\\\", SessionSchema);\\n\",\"import mongoose from \\\"mongoose\\\";\\nconst RoomSchema = new mongoose.Schema({\\n  createdAt: {\\n    type: Date,\\n    default: Date.now\\n  },\\n  name: {\\n    type: String,\\n    unique: true,\\n    required: true,\\n    minlength: 3,\\n    maxlength: 35\\n  },\\n  requests: { type: [String], default: [] },\\n  users: [{ type: mongoose.Schema.Types.ObjectId, ref: \\\"User\\\" }],\\n  leader: String,\\n  chat: {\\n    type: [\\n      {\\n        iv: String, // Hex encoded Initialization vector\\n        msg: String, // base64 encoded , AES 256 Encrypted cipher text\\n        from: String, // sender\\n        to: [{\\n          publicKey: String, // RSA public key string/pem\\n          username: String,\\n          key: String, // Base64 encoded ,AES 256 Encrypted Key\\n        }],\\n        isImg: Boolean,\\n        createdAt: { type: Date, default: Date.now }\\n      }\\n    ],\\n    default: []\\n  }\\n});\\n\\nexport default mongoose.model(\\\"Room\\\", RoomSchema);\\n\",\"module.exports = require(\\\"crypto\\\");\",\"module.exports = require(\\\"crypto-js\\\");\",\"module.exports = require(\\\"fs\\\");\",\"module.exports = require(\\\"constants\\\");\"]}","code":"!function(e){var o={};function t(n){if(o[n])return o[n].exports;var s=o[n]={i:n,l:!1,exports:{}};return e[n].call(s.exports,s,s.exports,t),s.l=!0,s.exports}t.m=e,t.c=o,t.d=function(e,o,n){t.o(e,o)||Object.defineProperty(e,o,{enumerable:!0,get:n})},t.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},t.t=function(e,o){if(1&o&&(e=t(e)),8&o)return e;if(4&o&&\"object\"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(t.r(n),Object.defineProperty(n,\"default\",{enumerable:!0,value:e}),2&o&&\"string\"!=typeof e)for(var s in e)t.d(n,s,function(o){return e[o]}.bind(null,s));return n},t.n=function(e){var o=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(o,\"a\",o),o},t.o=function(e,o){return Object.prototype.hasOwnProperty.call(e,o)},t.p=\"\",t(t.s=1)}([function(e,o){e.exports=require(\"mongoose\")},function(e,o,t){\"use strict\";var n=this&&this.__awaiter||function(e,o,t,n){return new(t||(t=Promise))(function(s,r){function i(e){try{a(n.next(e))}catch(e){r(e)}}function l(e){try{a(n.throw(e))}catch(e){r(e)}}function a(e){e.done?s(e.value):new t(function(o){o(e.value)}).then(i,l)}a((n=n.apply(e,o||[])).next())})};Object.defineProperty(o,\"__esModule\",{value:!0});const s=t(2),r=t(0),i=t(3),l=t(4),a=t(5),d=t(6),u=t(7),c=t(8),m=t(9),f=t(10),g=t(11),p=t(12),h=t(13),y=t(14),v=t(15),x=t(16),S=t(17);var b=t(18);console.log(b);let q=[];q.push({name:\"Av1\",uri:\"data:image/png;base64,\"+S.readFileSync(\"./assets/avatar1.png\",\"base64\")}),q.push({name:\"Av2\",uri:\"data:image/png;base64,\"+S.readFileSync(\"./assets/avatar2.png\",\"base64\")}),q.push({name:\"Av3\",uri:\"data:image/png;base64,\"+S.readFileSync(\"./assets/avatar3.png\",\"base64\")}),q.push({name:\"Av4\",uri:\"data:image/png;base64,\"+S.readFileSync(\"./assets/avatar4.png\",\"base64\")}),q.push({name:\"Av5\",uri:\"data:image/png;base64,\"+S.readFileSync(\"./assets/avatar5.png\",\"base64\")});let k=[];k.push({name:\"group\",uri:\"data:image/png;base64,\"+S.readFileSync(\"./assets/group.png\",\"base64\")}),k.push({name:\"noAv\",uri:\"data:image/png;base64,\"+S.readFileSync(\"./assets/noavatar.jpeg\",\"base64\")}),c.config();const O=s();O.use(d()),r.connect(\"mongodb://localhost:27017/Chat\",{useNewUrlParser:!0}).then(()=>console.log(`${process.env.USER} Connected to MongoDB `)).catch(e=>console.log(e)),O.use(a.urlencoded({extended:!1})),O.use(a.json()),O.use(u()),O.use(l()),O.use(i(\"common\")),O.get(\"/\",(e,o)=>{o.json({home:\"Key generation route\"})}),O.get(\"**\",(e,o)=>{o.json({success:\"Hello world from express\"})});const T=f.createServer(O),w=m(T);T.listen(process.env.PORT,()=>{console.log(`Express Server on port: ${process.env.PORT}`)});const E=e=>{const{username:o,password:t,passwordc:n}=e;let s={username:\"\",password:\"\",passwordc:\"\"};return null==o||\"\"===o?s.username=\"the username is a required field\":(o.length<3||o.length>35)&&(s.username=\"يجب على الاسم أن يتكون من 3~35 حرف\"),null==t||\"\"===t?s.password=\"the password is a required field\":t.length<8||t.length>35?s.password=\"the password must be 8~35 characters\":null!=n&&n!==t&&(s.passwordc=\"the two passwords must be equal\"),null==n?(delete s.passwordc,s.password+s.username===\"\"?{isValid:!0,errors:s}:{isValid:!1,errors:s}):s.password+s.passwordc+s.username===\"\"?{isValid:!0,errors:s}:{isValid:!1,errors:s}};w.on(\"connection\",e=>{console.log(`socket: ${e.id} connected`),e.on(\"validateRegister\",o=>n(this,void 0,void 0,function*(){let{errors:t,isValid:n}=E(o);if(n)try{let n=yield p.default.findOne({username:o.username});return n?(t.passwordc=`${n.username} is used by another user`,void w.to(e.id).emit(\"status\",{status:`${n.username} is used by another user`,errors:t})):void w.to(e.id).emit(\"validatedInput\",o.username)}catch(e){return void console.log(e)}else w.to(e.id).emit(\"status\",{status:`${e.id}'s reg-form is invalid`,errors:t}),console.log({authRefused:`${e.id}'s reg-form is invalid`,errors:t})})),e.on(\"register\",o=>n(this,void 0,void 0,function*(){let{password:t,username:n,publicKey:s}=o;try{let o=yield g.genSalt(10),r=yield g.hash(t,o);const i=new p.default({username:n,password:r,publicKey:s,avatar:k[yield k.findIndex(e=>\"noAv\"===e.name)]});yield i.save(),w.to(e.id).emit(\"registered\")}catch(e){return void console.log(e)}})),e.on(\"loginRequest\",o=>n(this,void 0,void 0,function*(){let{username:t,password:n}=o;console.log(`${t} is trying to login`);const{isValid:s,errors:r}=E(o);if(s)try{let o=yield p.default.findOne({username:t});if(!o)return r.password=\"The user doesn't exist\",console.log(\"the user doesn't exist\"),void w.to(e.id).emit(\"status\",{status:\"The user doesn't exist\",errors:r});if(!(yield g.compare(n,o.password)))return r.password=\"The password is invalid\",void w.to(e.id).emit(\"status\",{status:\"The password is Invalid\",errors:r});{let t=yield v.randomBytes(32).toString(\"hex\"),n=yield new h.default({token:t,user:o._id});o.session=n._id;let s=yield n.save(),r=yield o.save();w.to(e.id).emit(\"token\",{token:s.token,publicKey:r.publicKey,avatar:r.avatar,username:r.username})}}catch(e){console.log(e)}else w.to(e.id).emit(\"status\",{status:\"invalid registeration form\",errors:r})})),e.on(\"assignKey\",o=>n(this,void 0,void 0,function*(){console.log(\"Assigning a new key\");let{token:t,username:n,publicKey:s}=o;try{let o=yield h.default.findOne({token:t});if(!o)return void console.log(\"The Session Doesn't Exist\");{let t=yield p.default.findById(o.user);if(!t)return void console.log(\"The User Doesn't Exist\");{t.publicKey=s;let n=yield t.save();w.to(e.id).emit(\"keyPairAssigned\",{token:o.token,username:n.username,avatar:n.avatar})}}}catch(e){console.log(e)}})),e.on(\"validateToken\",o=>n(this,void 0,void 0,function*(){console.log(\"token\",o);let t=yield h.default.findOne({token:o});if(t){console.log(\"The Session Exists\");let o=yield p.default.findById(t.user);if(o){console.log(\"Token is Valid\");let n={token:t.token,avatar:o.avatar,username:o.username,publicKey:o.publicKey};return void w.to(e.id).emit(\"validToken\",n)}console.log(\"The User Doesn't Exist\")}else console.log(\"TokenValidation:||:The Session Doesn't Exist\")})),e.on(\"getImagesArray\",o=>{5===q.length&&h.default.findOne({token:o.token},(o,t)=>{o?console.log(o):null!=t&&p.default.findById(t.user,(o,t)=>{o?console.log(o):null!=t&&w.to(e.id).emit(\"imagesArray\",q)})})}),e.on(\"saveProfile\",o=>{console.log(\"Received Image data\"),h.default.findOne({token:o.token},(t,n)=>{t?console.log(t):null!=n&&p.default.findById(n.user,(t,s)=>{if(t)console.log(t);else if(null!=s){const t={token:n.token,username:s.username,avatar:s.avatar};if(o.avatar===s.avatar)return void w.to(e.id).emit(\"profileSaved\",t);s.avatar=o.avatar,s.save((o,t)=>{if(o)console.log(o);else if(null!==t&&null!==t){const o={token:n.token,username:t.username,avatar:t.avatar};console.log(\"Saved profile\"),w.to(e.id).emit(\"profileSaved\",o)}})}})})}),e.on(\"createRoom\",o=>n(this,void 0,void 0,function*(){let{token:t,name:n}=o;if(null==n||\"\"===n)w.to(e.id).emit(\"groupFormError\",\"اكتب اسم المجموعة\");else if(n.length<3||n.length>35)w.to(e.id).emit(\"groupFormError\",\"يجب على الاسم ان يتكون من 3~35 حرف\");else try{let o=yield h.default.findOne({token:t});if(o){let t=yield p.default.findById(o.user);if(t){if(yield y.default.findOne({name:n}))w.to(e.id).emit(\"groupFormError\",\"the room name is taken\");else{let o=new y.default({name:n,leader:t.username,users:[t._id]});yield t.rooms.push(o._id);let s=yield o.save(),r=yield t.save();w.to(e.id).emit(\"roomCreated\",s),console.log(`${r.username} created ${s.name}`)}}else w.to(e.id).emit(\"groupFormError\",\"failed to get the user for room creation\")}else w.to(e.id).emit(\"groupFormError\",\"failed to get the session for room creation\")}catch(e){return void console.log(e)}})),e.on(\"getRooms\",o=>{console.log(o),h.default.findOne({token:o},(o,t)=>{o?console.log(o):null!=t?p.default.findById(t.user,[\"rooms\",\"username\"]).then(o=>{o.populate(\"rooms\",(o,t)=>{t.rooms.forEach((o,t)=>{console.log(o),e.join(o.name),console.log(\"Joined\",o.name)}),w.to(e.id).emit(\"rooms\",t.rooms)})}).catch(e=>console.log(e)):console.log(\"The Session Doesn't Exists\")})}),e.on(\"logout\",o=>{console.log(`${o.username} is logging out`),h.default.findOne({token:o.token},(o,t)=>{o?console.log(o):null!=t?(t.remove(),console.log(\"The Session is Removed\"),w.to(e.id).emit(\"logedout\")):console.log(\"The Session Doesn't Exist\")})}),e.on(\"newMsg\",e=>{const{msg:o,token:t,roomName:n}=e;h.default.findOne({token:t},(e,t)=>{e?console.log(e):null==t?console.log(\"the token is expired\"):p.default.findById(t.user).then(e=>{null!=e?y.default.findOne({name:n}).populate(\"users\",[\"publicKey\",\"username\"]).then(t=>{if(null!=t){let n=v.randomBytes(8).toString(\"hex\"),s=v.randomBytes(32).toString(\"hex\"),r=x.AES.encrypt(o,s,{iv:n,mode:x.mode.CBC,padding:x.pad.Pkcs7}).toString();console.log(\"cipher-text\",r);let i=[],l=Buffer.from(s),a=e.username,d=[];t.users.forEach((o,s)=>{let a=v.publicEncrypt({key:o.publicKey,padding:b.RSA_PKCS1_PADDING},l).toString(\"base64\");i.push({roomName:t.name,from:e.username,msg:r,key:a,publicKey:o.publicKey,iv:n}),d.push({publicKey:o.publicKey,key:a,username:o.username})}),null===t.chat||void 0===t.chat||0===t.chat.length?t.chat=[{from:a,to:d,msg:r,isImage:!1,iv:n}]:t.chat.push({from:a,to:d,msg:r,isImg:!1,iv:n}),t.save().then(e=>{console.log(\"Saved Room\",e.name),console.log(i),w.to(e.name).emit(\"Msg\",i)}).catch(e=>console.log(e))}else console.log(\"the room doesn't exist\")}).catch(e=>console.log(e)):console.log(\"The User Doesn't Exist\")}).catch(e=>console.log(e))})}),e.on(\"invite\",o=>{const{room:t,user:n,username:s}=o;null==n||\"\"===n?w.to(e.id).emit(\"groupFormError\",\"اكتب اسم الشحص\"):n.length<3||n.length>30?w.to(e.id).emit(\"groupFormError\",\"يجب على الاسم أن يتكون من 3~35 حرف\"):p.default.findOne({username:n},(o,n)=>{o?console.log(o):null==n?w.to(e.id).emit(\"groupFormError\",\"لا يوجد هذا الشخص\"):y.default.findOne({name:t},(o,t)=>{if(o)console.log(o);else if(null==t)console.log(\"The Room doesn't Exist\");else if(t.leader===s)if(-1===n.rooms.indexOf(t._id)){-1===n.requests.findIndex(e=>e.roomName===t.name)?(n.requests.push({roomName:t.name,leader:t.leader}),n.save((o,s)=>{o?console.log(o):(w.to(e.id).emit(\"invited\"),console.log(`Invited ${n.username} ==room==> ${t.name} `))})):w.to(e.id).emit(\"groupFormError\",\"انتظر الشخص لكي يستجيب لدعوتك\")}else w.to(e.id).emit(\"groupFormError\",\"هذا الشخص عضو في المجموعة\");else console.log(\"you have to be the leader of the room to invite\")})})}),e.on(\"getRequests\",o=>{h.default.findOne({token:o}).then(o=>{null!=o?p.default.findById(o.user).then(o=>null==o?void console.log(\"The User is unavailable\"):(w.to(e.id).emit(\"userRequests\",o.requests),void console.log(`Sent userRequests to ${o.username}`,o.requests))):console.log(\"The Session is Expired\")}).catch(e=>console.log(e))}),e.on(\"acceptUserRequest\",o=>{let{token:t,roomName:n}=o;h.default.findOne({token:t}).then(o=>{null!=o?p.default.findById(o.user).then(o=>{null!=o?y.default.findOne({name:n}).then(t=>{if(null==t)console.log(\"The Room is unavailable\");else{let s=o.rooms.indexOf(t._id);if(console.log(\"refIndex\",s),-1===s){t.users.push(o._id),o.rooms.push(t._id);let s=o.requests.findIndex(e=>e.roomName===n);o.requests.splice(s,1),t.save().then(t=>{o.save().then(o=>{console.log(`${o.username} joined ${t.name}`),e.join(t.name),w.to(e.id).emit(\"invitationAccepted\",t.name)}).catch(e=>console.log(e))}).catch(e=>console.log(e))}else console.log(\"you are a member of this group\")}}).catch(e=>console.log(e)):console.log(\"The User is unavailable\")}):console.log(\"The Session is Expired\")}).catch(e=>console.log(e))}),e.on(\"refuseUserRequest\",o=>n(this,void 0,void 0,function*(){let{token:t,roomName:n}=o;try{let o=yield h.default.findOne({token:t});if(null==o)return void console.log(\"The Session Doesn't Exist\");{let t=yield p.default.findById(o.user);if(null==t)return void console.log(\"The User Doesn't Exist\");{let o=yield t.requests.findIndex(e=>e.roomName===n);yield t.requests.splice(o,1);let s=yield t.save();console.log(\"A User Invitation Has Been Deleted\",s.requests),w.to(e.id).emit(\"deletedUserRequest\",n)}}}catch(e){console.log(e)}})),e.on(\"refuseRoomRequest\",o=>n(this,void 0,void 0,function*(){let{token:t,roomName:n,person:s}=o;try{let o=yield h.default.findOne({token:t});if(null==o)return void console.log(\"The Session Doesn't Exist\");{let t=yield p.default.findById(o.user);if(null==t)return void console.log(\"The User Doesn't Exist\");{let o=yield y.default.findOne({name:n});if(!o)return void console.log(\"The room doesn't exist\");{let t=o.requests.indexOf(s);if(-1===t)return void console.log(\"The Request Doesn't exist\");yield o.requests.splice(t,1),yield o.save(),w.to(e.id).emit(\"roomRequestAccepted\",{person:s,roomName:n})}}}}catch(e){console.log(e)}})),e.on(\"joinRequest\",o=>n(this,void 0,void 0,function*(){const{token:t,name:n}=o;if(null==n||\"\"===n)w.to(e.id).emit(\"groupFormError\",\"اكتب اسم المجموعة\");else if(n.length<3||n.length>35)w.to(e.id).emit(\"groupFormError\",\"يجب على اسم المجموعة أن تتكون من 3~35 حرف\");else try{let o=yield h.default.findOne({token:t});if(null==o)return void console.log(\"The Session is Expired\");{let t=yield p.default.findById(o.user);if(null==t)return void console.log(\"The User doesn't exist\");{let o=yield y.default.findOne({name:n});if(null==o)return console.log(\"The Room doesn't exist\"),void w.to(e.id).emit(\"groupFormError\",\"لا توجد هذه مجموعة\");{let n=yield o.requests.indexOf(t.username);if(-1!==(yield o.users.indexOf(t._id)))w.to(e.id).emit(\"groupFormError\",\"أنت عضو في هذه المجموعة\");else if(-1===n){yield o.requests.push(t.username);let n=yield o.save();console.log(`${t.username} ==Requests==> ${n.leader} to join ${n.name}`),w.to(e.id).emit(\"requestSent\")}else console.log(\"The Request already exists\"),w.to(e.id).emit(\"groupFormError\",\"انتظر الرد على طلب الدخول\")}}}}catch(e){console.log(e)}})),e.on(\"acceptRoomRequest\",o=>n(this,void 0,void 0,function*(){let{token:t,roomName:n,person:s}=o;try{let o=yield h.default.findOne({token:t});if(!o)return void console.log(\"The Session Doesn't Exist\");if(!(yield p.default.findById(o.user)))return void console.log(\"The User Doesn't Exist\");{let o=yield p.default.findOne({username:s});if(!o)return void console.log(\"The Person you want to invite doesn't exist\");{let t=yield y.default.findOne({name:n});if(!t)return void console.log(\"The Room Doesn't Exist\");if(-1!==(yield t.users.indexOf(o._id)))return void console.log(`${o.username} already exists in ${t.name}`);{yield t.users.push(o._id);let n=yield t.requests.indexOf(o.username);-1!==n?yield t.requests.splice(n,1):console.log(\"The Request Doesn't Exist\");let s=yield t.save();yield o.rooms.push(s._id),o.save(),console.log(`${s.leader} accepted ${o.username}'s request to join ${t.name}`),w.to(e.id).emit(\"roomRequestAccepted\",{person:o.username,roomName:s.name,id:o._id})}}}}catch(e){console.log(e)}})),e.on(\"disconnect\",o=>{console.log(`${e.id} disconnected!!`),console.log(\"reason\",o)})})},function(e,o){e.exports=require(\"express\")},function(e,o){e.exports=require(\"morgan\")},function(e,o){e.exports=require(\"compression\")},function(e,o){e.exports=require(\"body-parser\")},function(e,o){e.exports=require(\"helmet\")},function(e,o){e.exports=require(\"cors\")},function(e,o){e.exports=require(\"dotenv\")},function(e,o){e.exports=require(\"socket.io\")},function(e,o){e.exports=require(\"http\")},function(e,o){e.exports=require(\"bcryptjs\")},function(e,o,t){\"use strict\";t.r(o);var n=t(0),s=t.n(n);const r=new s.a.Schema({username:{type:String,required:!0,unique:!0,minlength:3,maxlength:35},password:{type:String,required:!0},publicKey:{type:String,required:!0,unique:!0},session:{type:s.a.Schema.Types.ObjectId,ref:\"Session\",required:!1},avatar:{},rooms:{type:[{type:s.a.Schema.Types.ObjectId,ref:\"Room\"}],default:[]},requests:{type:[{roomName:String,leader:String}],default:[]},createdAt:{type:Date,default:Date.now}});o.default=s.a.model(\"User\",r)},function(e,o,t){\"use strict\";t.r(o);var n=t(0),s=t.n(n);const r=new s.a.Schema({createdAt:{type:Date,default:Date.now,expires:\"1d\"},token:{type:String,unique:!0},user:{type:s.a.Schema.Types.ObjectId,ref:\"User\"}});o.default=s.a.model(\"Session\",r)},function(e,o,t){\"use strict\";t.r(o);var n=t(0),s=t.n(n);const r=new s.a.Schema({createdAt:{type:Date,default:Date.now},name:{type:String,unique:!0,required:!0,minlength:3,maxlength:35},requests:{type:[String],default:[]},users:[{type:s.a.Schema.Types.ObjectId,ref:\"User\"}],leader:String,chat:{type:[{iv:String,msg:String,from:String,to:[{publicKey:String,username:String,key:String}],isImg:Boolean,createdAt:{type:Date,default:Date.now}}],default:[]}});o.default=s.a.model(\"Room\",r)},function(e,o){e.exports=require(\"crypto\")},function(e,o){e.exports=require(\"crypto-js\")},function(e,o){e.exports=require(\"fs\")},function(e,o){e.exports=require(\"constants\")}]);","extractedComments":[]}